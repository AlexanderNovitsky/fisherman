package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/internal/validation.AsyncValidationContext -o ./mocks\async_validation_contextmock.go

import (
	"fisherman/infrastructure"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AsyncValidationContextMock implements validation.AsyncValidationContext
type AsyncValidationContextMock struct {
	t minimock.Tester

	funcArgs          func() (sa1 []string)
	inspectFuncArgs   func()
	afterArgsCounter  uint64
	beforeArgsCounter uint64
	ArgsMock          mAsyncValidationContextMockArgs

	funcDeadline          func() (deadline time.Time, ok bool)
	inspectFuncDeadline   func()
	afterDeadlineCounter  uint64
	beforeDeadlineCounter uint64
	DeadlineMock          mAsyncValidationContextMockDeadline

	funcDone func() (ch1 <-chan struct {
	})
	inspectFuncDone   func()
	afterDoneCounter  uint64
	beforeDoneCounter uint64
	DoneMock          mAsyncValidationContextMockDone

	funcErr          func() (err error)
	inspectFuncErr   func()
	afterErrCounter  uint64
	beforeErrCounter uint64
	ErrMock          mAsyncValidationContextMockErr

	funcFiles          func() (f1 infrastructure.FileSystem)
	inspectFuncFiles   func()
	afterFilesCounter  uint64
	beforeFilesCounter uint64
	FilesMock          mAsyncValidationContextMockFiles

	funcMessage          func() (s1 string)
	inspectFuncMessage   func()
	afterMessageCounter  uint64
	beforeMessageCounter uint64
	MessageMock          mAsyncValidationContextMockMessage

	funcOutput          func() (w1 io.Writer)
	inspectFuncOutput   func()
	afterOutputCounter  uint64
	beforeOutputCounter uint64
	OutputMock          mAsyncValidationContextMockOutput

	funcRepository          func() (r1 infrastructure.Repository)
	inspectFuncRepository   func()
	afterRepositoryCounter  uint64
	beforeRepositoryCounter uint64
	RepositoryMock          mAsyncValidationContextMockRepository

	funcShell          func() (s1 infrastructure.Shell)
	inspectFuncShell   func()
	afterShellCounter  uint64
	beforeShellCounter uint64
	ShellMock          mAsyncValidationContextMockShell

	funcStop          func()
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mAsyncValidationContextMockStop

	funcValue          func(key interface{}) (p1 interface{})
	inspectFuncValue   func(key interface{})
	afterValueCounter  uint64
	beforeValueCounter uint64
	ValueMock          mAsyncValidationContextMockValue
}

// NewAsyncValidationContextMock returns a mock for validation.AsyncValidationContext
func NewAsyncValidationContextMock(t minimock.Tester) *AsyncValidationContextMock {
	m := &AsyncValidationContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArgsMock = mAsyncValidationContextMockArgs{mock: m}

	m.DeadlineMock = mAsyncValidationContextMockDeadline{mock: m}

	m.DoneMock = mAsyncValidationContextMockDone{mock: m}

	m.ErrMock = mAsyncValidationContextMockErr{mock: m}

	m.FilesMock = mAsyncValidationContextMockFiles{mock: m}

	m.MessageMock = mAsyncValidationContextMockMessage{mock: m}

	m.OutputMock = mAsyncValidationContextMockOutput{mock: m}

	m.RepositoryMock = mAsyncValidationContextMockRepository{mock: m}

	m.ShellMock = mAsyncValidationContextMockShell{mock: m}

	m.StopMock = mAsyncValidationContextMockStop{mock: m}

	m.ValueMock = mAsyncValidationContextMockValue{mock: m}
	m.ValueMock.callArgs = []*AsyncValidationContextMockValueParams{}

	return m
}

type mAsyncValidationContextMockArgs struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockArgsExpectation
	expectations       []*AsyncValidationContextMockArgsExpectation
}

// AsyncValidationContextMockArgsExpectation specifies expectation struct of the AsyncValidationContext.Args
type AsyncValidationContextMockArgsExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockArgsResults
	Counter uint64
}

// AsyncValidationContextMockArgsResults contains results of the AsyncValidationContext.Args
type AsyncValidationContextMockArgsResults struct {
	sa1 []string
}

// Expect sets up expected params for AsyncValidationContext.Args
func (mmArgs *mAsyncValidationContextMockArgs) Expect() *mAsyncValidationContextMockArgs {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("AsyncValidationContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &AsyncValidationContextMockArgsExpectation{}
	}

	return mmArgs
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Args
func (mmArgs *mAsyncValidationContextMockArgs) Inspect(f func()) *mAsyncValidationContextMockArgs {
	if mmArgs.mock.inspectFuncArgs != nil {
		mmArgs.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Args")
	}

	mmArgs.mock.inspectFuncArgs = f

	return mmArgs
}

// Return sets up results that will be returned by AsyncValidationContext.Args
func (mmArgs *mAsyncValidationContextMockArgs) Return(sa1 []string) *AsyncValidationContextMock {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("AsyncValidationContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &AsyncValidationContextMockArgsExpectation{mock: mmArgs.mock}
	}
	mmArgs.defaultExpectation.results = &AsyncValidationContextMockArgsResults{sa1}
	return mmArgs.mock
}

//Set uses given function f to mock the AsyncValidationContext.Args method
func (mmArgs *mAsyncValidationContextMockArgs) Set(f func() (sa1 []string)) *AsyncValidationContextMock {
	if mmArgs.defaultExpectation != nil {
		mmArgs.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Args method")
	}

	if len(mmArgs.expectations) > 0 {
		mmArgs.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Args method")
	}

	mmArgs.mock.funcArgs = f
	return mmArgs.mock
}

// Args implements validation.AsyncValidationContext
func (mmArgs *AsyncValidationContextMock) Args() (sa1 []string) {
	mm_atomic.AddUint64(&mmArgs.beforeArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmArgs.afterArgsCounter, 1)

	if mmArgs.inspectFuncArgs != nil {
		mmArgs.inspectFuncArgs()
	}

	if mmArgs.ArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArgs.ArgsMock.defaultExpectation.Counter, 1)

		mm_results := mmArgs.ArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmArgs.t.Fatal("No results are set for the AsyncValidationContextMock.Args")
		}
		return (*mm_results).sa1
	}
	if mmArgs.funcArgs != nil {
		return mmArgs.funcArgs()
	}
	mmArgs.t.Fatalf("Unexpected call to AsyncValidationContextMock.Args.")
	return
}

// ArgsAfterCounter returns a count of finished AsyncValidationContextMock.Args invocations
func (mmArgs *AsyncValidationContextMock) ArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.afterArgsCounter)
}

// ArgsBeforeCounter returns a count of AsyncValidationContextMock.Args invocations
func (mmArgs *AsyncValidationContextMock) ArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.beforeArgsCounter)
}

// MinimockArgsDone returns true if the count of the Args invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockArgsDone() bool {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	return true
}

// MinimockArgsInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockArgsInspect() {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Args")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Args")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Args")
	}
}

type mAsyncValidationContextMockDeadline struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockDeadlineExpectation
	expectations       []*AsyncValidationContextMockDeadlineExpectation
}

// AsyncValidationContextMockDeadlineExpectation specifies expectation struct of the AsyncValidationContext.Deadline
type AsyncValidationContextMockDeadlineExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockDeadlineResults
	Counter uint64
}

// AsyncValidationContextMockDeadlineResults contains results of the AsyncValidationContext.Deadline
type AsyncValidationContextMockDeadlineResults struct {
	deadline time.Time
	ok       bool
}

// Expect sets up expected params for AsyncValidationContext.Deadline
func (mmDeadline *mAsyncValidationContextMockDeadline) Expect() *mAsyncValidationContextMockDeadline {
	if mmDeadline.mock.funcDeadline != nil {
		mmDeadline.mock.t.Fatalf("AsyncValidationContextMock.Deadline mock is already set by Set")
	}

	if mmDeadline.defaultExpectation == nil {
		mmDeadline.defaultExpectation = &AsyncValidationContextMockDeadlineExpectation{}
	}

	return mmDeadline
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Deadline
func (mmDeadline *mAsyncValidationContextMockDeadline) Inspect(f func()) *mAsyncValidationContextMockDeadline {
	if mmDeadline.mock.inspectFuncDeadline != nil {
		mmDeadline.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Deadline")
	}

	mmDeadline.mock.inspectFuncDeadline = f

	return mmDeadline
}

// Return sets up results that will be returned by AsyncValidationContext.Deadline
func (mmDeadline *mAsyncValidationContextMockDeadline) Return(deadline time.Time, ok bool) *AsyncValidationContextMock {
	if mmDeadline.mock.funcDeadline != nil {
		mmDeadline.mock.t.Fatalf("AsyncValidationContextMock.Deadline mock is already set by Set")
	}

	if mmDeadline.defaultExpectation == nil {
		mmDeadline.defaultExpectation = &AsyncValidationContextMockDeadlineExpectation{mock: mmDeadline.mock}
	}
	mmDeadline.defaultExpectation.results = &AsyncValidationContextMockDeadlineResults{deadline, ok}
	return mmDeadline.mock
}

//Set uses given function f to mock the AsyncValidationContext.Deadline method
func (mmDeadline *mAsyncValidationContextMockDeadline) Set(f func() (deadline time.Time, ok bool)) *AsyncValidationContextMock {
	if mmDeadline.defaultExpectation != nil {
		mmDeadline.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Deadline method")
	}

	if len(mmDeadline.expectations) > 0 {
		mmDeadline.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Deadline method")
	}

	mmDeadline.mock.funcDeadline = f
	return mmDeadline.mock
}

// Deadline implements validation.AsyncValidationContext
func (mmDeadline *AsyncValidationContextMock) Deadline() (deadline time.Time, ok bool) {
	mm_atomic.AddUint64(&mmDeadline.beforeDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmDeadline.afterDeadlineCounter, 1)

	if mmDeadline.inspectFuncDeadline != nil {
		mmDeadline.inspectFuncDeadline()
	}

	if mmDeadline.DeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeadline.DeadlineMock.defaultExpectation.Counter, 1)

		mm_results := mmDeadline.DeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmDeadline.t.Fatal("No results are set for the AsyncValidationContextMock.Deadline")
		}
		return (*mm_results).deadline, (*mm_results).ok
	}
	if mmDeadline.funcDeadline != nil {
		return mmDeadline.funcDeadline()
	}
	mmDeadline.t.Fatalf("Unexpected call to AsyncValidationContextMock.Deadline.")
	return
}

// DeadlineAfterCounter returns a count of finished AsyncValidationContextMock.Deadline invocations
func (mmDeadline *AsyncValidationContextMock) DeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeadline.afterDeadlineCounter)
}

// DeadlineBeforeCounter returns a count of AsyncValidationContextMock.Deadline invocations
func (mmDeadline *AsyncValidationContextMock) DeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeadline.beforeDeadlineCounter)
}

// MinimockDeadlineDone returns true if the count of the Deadline invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockDeadlineDone() bool {
	for _, e := range m.DeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeadline != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeadlineInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockDeadlineInspect() {
	for _, e := range m.DeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Deadline")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Deadline")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeadline != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Deadline")
	}
}

type mAsyncValidationContextMockDone struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockDoneExpectation
	expectations       []*AsyncValidationContextMockDoneExpectation
}

// AsyncValidationContextMockDoneExpectation specifies expectation struct of the AsyncValidationContext.Done
type AsyncValidationContextMockDoneExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockDoneResults
	Counter uint64
}

// AsyncValidationContextMockDoneResults contains results of the AsyncValidationContext.Done
type AsyncValidationContextMockDoneResults struct {
	ch1 <-chan struct {
	}
}

// Expect sets up expected params for AsyncValidationContext.Done
func (mmDone *mAsyncValidationContextMockDone) Expect() *mAsyncValidationContextMockDone {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("AsyncValidationContextMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &AsyncValidationContextMockDoneExpectation{}
	}

	return mmDone
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Done
func (mmDone *mAsyncValidationContextMockDone) Inspect(f func()) *mAsyncValidationContextMockDone {
	if mmDone.mock.inspectFuncDone != nil {
		mmDone.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Done")
	}

	mmDone.mock.inspectFuncDone = f

	return mmDone
}

// Return sets up results that will be returned by AsyncValidationContext.Done
func (mmDone *mAsyncValidationContextMockDone) Return(ch1 <-chan struct {
}) *AsyncValidationContextMock {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("AsyncValidationContextMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &AsyncValidationContextMockDoneExpectation{mock: mmDone.mock}
	}
	mmDone.defaultExpectation.results = &AsyncValidationContextMockDoneResults{ch1}
	return mmDone.mock
}

//Set uses given function f to mock the AsyncValidationContext.Done method
func (mmDone *mAsyncValidationContextMockDone) Set(f func() (ch1 <-chan struct {
})) *AsyncValidationContextMock {
	if mmDone.defaultExpectation != nil {
		mmDone.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Done method")
	}

	if len(mmDone.expectations) > 0 {
		mmDone.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Done method")
	}

	mmDone.mock.funcDone = f
	return mmDone.mock
}

// Done implements validation.AsyncValidationContext
func (mmDone *AsyncValidationContextMock) Done() (ch1 <-chan struct {
}) {
	mm_atomic.AddUint64(&mmDone.beforeDoneCounter, 1)
	defer mm_atomic.AddUint64(&mmDone.afterDoneCounter, 1)

	if mmDone.inspectFuncDone != nil {
		mmDone.inspectFuncDone()
	}

	if mmDone.DoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDone.DoneMock.defaultExpectation.Counter, 1)

		mm_results := mmDone.DoneMock.defaultExpectation.results
		if mm_results == nil {
			mmDone.t.Fatal("No results are set for the AsyncValidationContextMock.Done")
		}
		return (*mm_results).ch1
	}
	if mmDone.funcDone != nil {
		return mmDone.funcDone()
	}
	mmDone.t.Fatalf("Unexpected call to AsyncValidationContextMock.Done.")
	return
}

// DoneAfterCounter returns a count of finished AsyncValidationContextMock.Done invocations
func (mmDone *AsyncValidationContextMock) DoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.afterDoneCounter)
}

// DoneBeforeCounter returns a count of AsyncValidationContextMock.Done invocations
func (mmDone *AsyncValidationContextMock) DoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.beforeDoneCounter)
}

// MinimockDoneDone returns true if the count of the Done invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockDoneDone() bool {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoneInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockDoneInspect() {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Done")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Done")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Done")
	}
}

type mAsyncValidationContextMockErr struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockErrExpectation
	expectations       []*AsyncValidationContextMockErrExpectation
}

// AsyncValidationContextMockErrExpectation specifies expectation struct of the AsyncValidationContext.Err
type AsyncValidationContextMockErrExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockErrResults
	Counter uint64
}

// AsyncValidationContextMockErrResults contains results of the AsyncValidationContext.Err
type AsyncValidationContextMockErrResults struct {
	err error
}

// Expect sets up expected params for AsyncValidationContext.Err
func (mmErr *mAsyncValidationContextMockErr) Expect() *mAsyncValidationContextMockErr {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("AsyncValidationContextMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &AsyncValidationContextMockErrExpectation{}
	}

	return mmErr
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Err
func (mmErr *mAsyncValidationContextMockErr) Inspect(f func()) *mAsyncValidationContextMockErr {
	if mmErr.mock.inspectFuncErr != nil {
		mmErr.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Err")
	}

	mmErr.mock.inspectFuncErr = f

	return mmErr
}

// Return sets up results that will be returned by AsyncValidationContext.Err
func (mmErr *mAsyncValidationContextMockErr) Return(err error) *AsyncValidationContextMock {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("AsyncValidationContextMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &AsyncValidationContextMockErrExpectation{mock: mmErr.mock}
	}
	mmErr.defaultExpectation.results = &AsyncValidationContextMockErrResults{err}
	return mmErr.mock
}

//Set uses given function f to mock the AsyncValidationContext.Err method
func (mmErr *mAsyncValidationContextMockErr) Set(f func() (err error)) *AsyncValidationContextMock {
	if mmErr.defaultExpectation != nil {
		mmErr.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Err method")
	}

	if len(mmErr.expectations) > 0 {
		mmErr.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Err method")
	}

	mmErr.mock.funcErr = f
	return mmErr.mock
}

// Err implements validation.AsyncValidationContext
func (mmErr *AsyncValidationContextMock) Err() (err error) {
	mm_atomic.AddUint64(&mmErr.beforeErrCounter, 1)
	defer mm_atomic.AddUint64(&mmErr.afterErrCounter, 1)

	if mmErr.inspectFuncErr != nil {
		mmErr.inspectFuncErr()
	}

	if mmErr.ErrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErr.ErrMock.defaultExpectation.Counter, 1)

		mm_results := mmErr.ErrMock.defaultExpectation.results
		if mm_results == nil {
			mmErr.t.Fatal("No results are set for the AsyncValidationContextMock.Err")
		}
		return (*mm_results).err
	}
	if mmErr.funcErr != nil {
		return mmErr.funcErr()
	}
	mmErr.t.Fatalf("Unexpected call to AsyncValidationContextMock.Err.")
	return
}

// ErrAfterCounter returns a count of finished AsyncValidationContextMock.Err invocations
func (mmErr *AsyncValidationContextMock) ErrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.afterErrCounter)
}

// ErrBeforeCounter returns a count of AsyncValidationContextMock.Err invocations
func (mmErr *AsyncValidationContextMock) ErrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.beforeErrCounter)
}

// MinimockErrDone returns true if the count of the Err invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockErrDone() bool {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockErrInspect() {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Err")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Err")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Err")
	}
}

type mAsyncValidationContextMockFiles struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockFilesExpectation
	expectations       []*AsyncValidationContextMockFilesExpectation
}

// AsyncValidationContextMockFilesExpectation specifies expectation struct of the AsyncValidationContext.Files
type AsyncValidationContextMockFilesExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockFilesResults
	Counter uint64
}

// AsyncValidationContextMockFilesResults contains results of the AsyncValidationContext.Files
type AsyncValidationContextMockFilesResults struct {
	f1 infrastructure.FileSystem
}

// Expect sets up expected params for AsyncValidationContext.Files
func (mmFiles *mAsyncValidationContextMockFiles) Expect() *mAsyncValidationContextMockFiles {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("AsyncValidationContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &AsyncValidationContextMockFilesExpectation{}
	}

	return mmFiles
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Files
func (mmFiles *mAsyncValidationContextMockFiles) Inspect(f func()) *mAsyncValidationContextMockFiles {
	if mmFiles.mock.inspectFuncFiles != nil {
		mmFiles.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Files")
	}

	mmFiles.mock.inspectFuncFiles = f

	return mmFiles
}

// Return sets up results that will be returned by AsyncValidationContext.Files
func (mmFiles *mAsyncValidationContextMockFiles) Return(f1 infrastructure.FileSystem) *AsyncValidationContextMock {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("AsyncValidationContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &AsyncValidationContextMockFilesExpectation{mock: mmFiles.mock}
	}
	mmFiles.defaultExpectation.results = &AsyncValidationContextMockFilesResults{f1}
	return mmFiles.mock
}

//Set uses given function f to mock the AsyncValidationContext.Files method
func (mmFiles *mAsyncValidationContextMockFiles) Set(f func() (f1 infrastructure.FileSystem)) *AsyncValidationContextMock {
	if mmFiles.defaultExpectation != nil {
		mmFiles.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Files method")
	}

	if len(mmFiles.expectations) > 0 {
		mmFiles.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Files method")
	}

	mmFiles.mock.funcFiles = f
	return mmFiles.mock
}

// Files implements validation.AsyncValidationContext
func (mmFiles *AsyncValidationContextMock) Files() (f1 infrastructure.FileSystem) {
	mm_atomic.AddUint64(&mmFiles.beforeFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmFiles.afterFilesCounter, 1)

	if mmFiles.inspectFuncFiles != nil {
		mmFiles.inspectFuncFiles()
	}

	if mmFiles.FilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFiles.FilesMock.defaultExpectation.Counter, 1)

		mm_results := mmFiles.FilesMock.defaultExpectation.results
		if mm_results == nil {
			mmFiles.t.Fatal("No results are set for the AsyncValidationContextMock.Files")
		}
		return (*mm_results).f1
	}
	if mmFiles.funcFiles != nil {
		return mmFiles.funcFiles()
	}
	mmFiles.t.Fatalf("Unexpected call to AsyncValidationContextMock.Files.")
	return
}

// FilesAfterCounter returns a count of finished AsyncValidationContextMock.Files invocations
func (mmFiles *AsyncValidationContextMock) FilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.afterFilesCounter)
}

// FilesBeforeCounter returns a count of AsyncValidationContextMock.Files invocations
func (mmFiles *AsyncValidationContextMock) FilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.beforeFilesCounter)
}

// MinimockFilesDone returns true if the count of the Files invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockFilesDone() bool {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	return true
}

// MinimockFilesInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockFilesInspect() {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Files")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Files")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Files")
	}
}

type mAsyncValidationContextMockMessage struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockMessageExpectation
	expectations       []*AsyncValidationContextMockMessageExpectation
}

// AsyncValidationContextMockMessageExpectation specifies expectation struct of the AsyncValidationContext.Message
type AsyncValidationContextMockMessageExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockMessageResults
	Counter uint64
}

// AsyncValidationContextMockMessageResults contains results of the AsyncValidationContext.Message
type AsyncValidationContextMockMessageResults struct {
	s1 string
}

// Expect sets up expected params for AsyncValidationContext.Message
func (mmMessage *mAsyncValidationContextMockMessage) Expect() *mAsyncValidationContextMockMessage {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("AsyncValidationContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &AsyncValidationContextMockMessageExpectation{}
	}

	return mmMessage
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Message
func (mmMessage *mAsyncValidationContextMockMessage) Inspect(f func()) *mAsyncValidationContextMockMessage {
	if mmMessage.mock.inspectFuncMessage != nil {
		mmMessage.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Message")
	}

	mmMessage.mock.inspectFuncMessage = f

	return mmMessage
}

// Return sets up results that will be returned by AsyncValidationContext.Message
func (mmMessage *mAsyncValidationContextMockMessage) Return(s1 string) *AsyncValidationContextMock {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("AsyncValidationContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &AsyncValidationContextMockMessageExpectation{mock: mmMessage.mock}
	}
	mmMessage.defaultExpectation.results = &AsyncValidationContextMockMessageResults{s1}
	return mmMessage.mock
}

//Set uses given function f to mock the AsyncValidationContext.Message method
func (mmMessage *mAsyncValidationContextMockMessage) Set(f func() (s1 string)) *AsyncValidationContextMock {
	if mmMessage.defaultExpectation != nil {
		mmMessage.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Message method")
	}

	if len(mmMessage.expectations) > 0 {
		mmMessage.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Message method")
	}

	mmMessage.mock.funcMessage = f
	return mmMessage.mock
}

// Message implements validation.AsyncValidationContext
func (mmMessage *AsyncValidationContextMock) Message() (s1 string) {
	mm_atomic.AddUint64(&mmMessage.beforeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmMessage.afterMessageCounter, 1)

	if mmMessage.inspectFuncMessage != nil {
		mmMessage.inspectFuncMessage()
	}

	if mmMessage.MessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMessage.MessageMock.defaultExpectation.Counter, 1)

		mm_results := mmMessage.MessageMock.defaultExpectation.results
		if mm_results == nil {
			mmMessage.t.Fatal("No results are set for the AsyncValidationContextMock.Message")
		}
		return (*mm_results).s1
	}
	if mmMessage.funcMessage != nil {
		return mmMessage.funcMessage()
	}
	mmMessage.t.Fatalf("Unexpected call to AsyncValidationContextMock.Message.")
	return
}

// MessageAfterCounter returns a count of finished AsyncValidationContextMock.Message invocations
func (mmMessage *AsyncValidationContextMock) MessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.afterMessageCounter)
}

// MessageBeforeCounter returns a count of AsyncValidationContextMock.Message invocations
func (mmMessage *AsyncValidationContextMock) MessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.beforeMessageCounter)
}

// MinimockMessageDone returns true if the count of the Message invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockMessageDone() bool {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockMessageInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockMessageInspect() {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Message")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Message")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Message")
	}
}

type mAsyncValidationContextMockOutput struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockOutputExpectation
	expectations       []*AsyncValidationContextMockOutputExpectation
}

// AsyncValidationContextMockOutputExpectation specifies expectation struct of the AsyncValidationContext.Output
type AsyncValidationContextMockOutputExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockOutputResults
	Counter uint64
}

// AsyncValidationContextMockOutputResults contains results of the AsyncValidationContext.Output
type AsyncValidationContextMockOutputResults struct {
	w1 io.Writer
}

// Expect sets up expected params for AsyncValidationContext.Output
func (mmOutput *mAsyncValidationContextMockOutput) Expect() *mAsyncValidationContextMockOutput {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("AsyncValidationContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &AsyncValidationContextMockOutputExpectation{}
	}

	return mmOutput
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Output
func (mmOutput *mAsyncValidationContextMockOutput) Inspect(f func()) *mAsyncValidationContextMockOutput {
	if mmOutput.mock.inspectFuncOutput != nil {
		mmOutput.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Output")
	}

	mmOutput.mock.inspectFuncOutput = f

	return mmOutput
}

// Return sets up results that will be returned by AsyncValidationContext.Output
func (mmOutput *mAsyncValidationContextMockOutput) Return(w1 io.Writer) *AsyncValidationContextMock {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("AsyncValidationContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &AsyncValidationContextMockOutputExpectation{mock: mmOutput.mock}
	}
	mmOutput.defaultExpectation.results = &AsyncValidationContextMockOutputResults{w1}
	return mmOutput.mock
}

//Set uses given function f to mock the AsyncValidationContext.Output method
func (mmOutput *mAsyncValidationContextMockOutput) Set(f func() (w1 io.Writer)) *AsyncValidationContextMock {
	if mmOutput.defaultExpectation != nil {
		mmOutput.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Output method")
	}

	if len(mmOutput.expectations) > 0 {
		mmOutput.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Output method")
	}

	mmOutput.mock.funcOutput = f
	return mmOutput.mock
}

// Output implements validation.AsyncValidationContext
func (mmOutput *AsyncValidationContextMock) Output() (w1 io.Writer) {
	mm_atomic.AddUint64(&mmOutput.beforeOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmOutput.afterOutputCounter, 1)

	if mmOutput.inspectFuncOutput != nil {
		mmOutput.inspectFuncOutput()
	}

	if mmOutput.OutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOutput.OutputMock.defaultExpectation.Counter, 1)

		mm_results := mmOutput.OutputMock.defaultExpectation.results
		if mm_results == nil {
			mmOutput.t.Fatal("No results are set for the AsyncValidationContextMock.Output")
		}
		return (*mm_results).w1
	}
	if mmOutput.funcOutput != nil {
		return mmOutput.funcOutput()
	}
	mmOutput.t.Fatalf("Unexpected call to AsyncValidationContextMock.Output.")
	return
}

// OutputAfterCounter returns a count of finished AsyncValidationContextMock.Output invocations
func (mmOutput *AsyncValidationContextMock) OutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.afterOutputCounter)
}

// OutputBeforeCounter returns a count of AsyncValidationContextMock.Output invocations
func (mmOutput *AsyncValidationContextMock) OutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.beforeOutputCounter)
}

// MinimockOutputDone returns true if the count of the Output invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockOutputDone() bool {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	return true
}

// MinimockOutputInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockOutputInspect() {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Output")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Output")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Output")
	}
}

type mAsyncValidationContextMockRepository struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockRepositoryExpectation
	expectations       []*AsyncValidationContextMockRepositoryExpectation
}

// AsyncValidationContextMockRepositoryExpectation specifies expectation struct of the AsyncValidationContext.Repository
type AsyncValidationContextMockRepositoryExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockRepositoryResults
	Counter uint64
}

// AsyncValidationContextMockRepositoryResults contains results of the AsyncValidationContext.Repository
type AsyncValidationContextMockRepositoryResults struct {
	r1 infrastructure.Repository
}

// Expect sets up expected params for AsyncValidationContext.Repository
func (mmRepository *mAsyncValidationContextMockRepository) Expect() *mAsyncValidationContextMockRepository {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("AsyncValidationContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &AsyncValidationContextMockRepositoryExpectation{}
	}

	return mmRepository
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Repository
func (mmRepository *mAsyncValidationContextMockRepository) Inspect(f func()) *mAsyncValidationContextMockRepository {
	if mmRepository.mock.inspectFuncRepository != nil {
		mmRepository.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Repository")
	}

	mmRepository.mock.inspectFuncRepository = f

	return mmRepository
}

// Return sets up results that will be returned by AsyncValidationContext.Repository
func (mmRepository *mAsyncValidationContextMockRepository) Return(r1 infrastructure.Repository) *AsyncValidationContextMock {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("AsyncValidationContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &AsyncValidationContextMockRepositoryExpectation{mock: mmRepository.mock}
	}
	mmRepository.defaultExpectation.results = &AsyncValidationContextMockRepositoryResults{r1}
	return mmRepository.mock
}

//Set uses given function f to mock the AsyncValidationContext.Repository method
func (mmRepository *mAsyncValidationContextMockRepository) Set(f func() (r1 infrastructure.Repository)) *AsyncValidationContextMock {
	if mmRepository.defaultExpectation != nil {
		mmRepository.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Repository method")
	}

	if len(mmRepository.expectations) > 0 {
		mmRepository.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Repository method")
	}

	mmRepository.mock.funcRepository = f
	return mmRepository.mock
}

// Repository implements validation.AsyncValidationContext
func (mmRepository *AsyncValidationContextMock) Repository() (r1 infrastructure.Repository) {
	mm_atomic.AddUint64(&mmRepository.beforeRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmRepository.afterRepositoryCounter, 1)

	if mmRepository.inspectFuncRepository != nil {
		mmRepository.inspectFuncRepository()
	}

	if mmRepository.RepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepository.RepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmRepository.RepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmRepository.t.Fatal("No results are set for the AsyncValidationContextMock.Repository")
		}
		return (*mm_results).r1
	}
	if mmRepository.funcRepository != nil {
		return mmRepository.funcRepository()
	}
	mmRepository.t.Fatalf("Unexpected call to AsyncValidationContextMock.Repository.")
	return
}

// RepositoryAfterCounter returns a count of finished AsyncValidationContextMock.Repository invocations
func (mmRepository *AsyncValidationContextMock) RepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.afterRepositoryCounter)
}

// RepositoryBeforeCounter returns a count of AsyncValidationContextMock.Repository invocations
func (mmRepository *AsyncValidationContextMock) RepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.beforeRepositoryCounter)
}

// MinimockRepositoryDone returns true if the count of the Repository invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockRepositoryDone() bool {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockRepositoryInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockRepositoryInspect() {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Repository")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Repository")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Repository")
	}
}

type mAsyncValidationContextMockShell struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockShellExpectation
	expectations       []*AsyncValidationContextMockShellExpectation
}

// AsyncValidationContextMockShellExpectation specifies expectation struct of the AsyncValidationContext.Shell
type AsyncValidationContextMockShellExpectation struct {
	mock *AsyncValidationContextMock

	results *AsyncValidationContextMockShellResults
	Counter uint64
}

// AsyncValidationContextMockShellResults contains results of the AsyncValidationContext.Shell
type AsyncValidationContextMockShellResults struct {
	s1 infrastructure.Shell
}

// Expect sets up expected params for AsyncValidationContext.Shell
func (mmShell *mAsyncValidationContextMockShell) Expect() *mAsyncValidationContextMockShell {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("AsyncValidationContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &AsyncValidationContextMockShellExpectation{}
	}

	return mmShell
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Shell
func (mmShell *mAsyncValidationContextMockShell) Inspect(f func()) *mAsyncValidationContextMockShell {
	if mmShell.mock.inspectFuncShell != nil {
		mmShell.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Shell")
	}

	mmShell.mock.inspectFuncShell = f

	return mmShell
}

// Return sets up results that will be returned by AsyncValidationContext.Shell
func (mmShell *mAsyncValidationContextMockShell) Return(s1 infrastructure.Shell) *AsyncValidationContextMock {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("AsyncValidationContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &AsyncValidationContextMockShellExpectation{mock: mmShell.mock}
	}
	mmShell.defaultExpectation.results = &AsyncValidationContextMockShellResults{s1}
	return mmShell.mock
}

//Set uses given function f to mock the AsyncValidationContext.Shell method
func (mmShell *mAsyncValidationContextMockShell) Set(f func() (s1 infrastructure.Shell)) *AsyncValidationContextMock {
	if mmShell.defaultExpectation != nil {
		mmShell.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Shell method")
	}

	if len(mmShell.expectations) > 0 {
		mmShell.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Shell method")
	}

	mmShell.mock.funcShell = f
	return mmShell.mock
}

// Shell implements validation.AsyncValidationContext
func (mmShell *AsyncValidationContextMock) Shell() (s1 infrastructure.Shell) {
	mm_atomic.AddUint64(&mmShell.beforeShellCounter, 1)
	defer mm_atomic.AddUint64(&mmShell.afterShellCounter, 1)

	if mmShell.inspectFuncShell != nil {
		mmShell.inspectFuncShell()
	}

	if mmShell.ShellMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShell.ShellMock.defaultExpectation.Counter, 1)

		mm_results := mmShell.ShellMock.defaultExpectation.results
		if mm_results == nil {
			mmShell.t.Fatal("No results are set for the AsyncValidationContextMock.Shell")
		}
		return (*mm_results).s1
	}
	if mmShell.funcShell != nil {
		return mmShell.funcShell()
	}
	mmShell.t.Fatalf("Unexpected call to AsyncValidationContextMock.Shell.")
	return
}

// ShellAfterCounter returns a count of finished AsyncValidationContextMock.Shell invocations
func (mmShell *AsyncValidationContextMock) ShellAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.afterShellCounter)
}

// ShellBeforeCounter returns a count of AsyncValidationContextMock.Shell invocations
func (mmShell *AsyncValidationContextMock) ShellBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.beforeShellCounter)
}

// MinimockShellDone returns true if the count of the Shell invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockShellDone() bool {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	return true
}

// MinimockShellInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockShellInspect() {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Shell")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Shell")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Shell")
	}
}

type mAsyncValidationContextMockStop struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockStopExpectation
	expectations       []*AsyncValidationContextMockStopExpectation
}

// AsyncValidationContextMockStopExpectation specifies expectation struct of the AsyncValidationContext.Stop
type AsyncValidationContextMockStopExpectation struct {
	mock *AsyncValidationContextMock

	Counter uint64
}

// Expect sets up expected params for AsyncValidationContext.Stop
func (mmStop *mAsyncValidationContextMockStop) Expect() *mAsyncValidationContextMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("AsyncValidationContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &AsyncValidationContextMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Stop
func (mmStop *mAsyncValidationContextMockStop) Inspect(f func()) *mAsyncValidationContextMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by AsyncValidationContext.Stop
func (mmStop *mAsyncValidationContextMockStop) Return() *AsyncValidationContextMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("AsyncValidationContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &AsyncValidationContextMockStopExpectation{mock: mmStop.mock}
	}

	return mmStop.mock
}

//Set uses given function f to mock the AsyncValidationContext.Stop method
func (mmStop *mAsyncValidationContextMockStop) Set(f func()) *AsyncValidationContextMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// Stop implements validation.AsyncValidationContext
func (mmStop *AsyncValidationContextMock) Stop() {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		return

	}
	if mmStop.funcStop != nil {
		mmStop.funcStop()
		return
	}
	mmStop.t.Fatalf("Unexpected call to AsyncValidationContextMock.Stop.")

}

// StopAfterCounter returns a count of finished AsyncValidationContextMock.Stop invocations
func (mmStop *AsyncValidationContextMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of AsyncValidationContextMock.Stop invocations
func (mmStop *AsyncValidationContextMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncValidationContextMock.Stop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Stop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Stop")
	}
}

type mAsyncValidationContextMockValue struct {
	mock               *AsyncValidationContextMock
	defaultExpectation *AsyncValidationContextMockValueExpectation
	expectations       []*AsyncValidationContextMockValueExpectation

	callArgs []*AsyncValidationContextMockValueParams
	mutex    sync.RWMutex
}

// AsyncValidationContextMockValueExpectation specifies expectation struct of the AsyncValidationContext.Value
type AsyncValidationContextMockValueExpectation struct {
	mock    *AsyncValidationContextMock
	params  *AsyncValidationContextMockValueParams
	results *AsyncValidationContextMockValueResults
	Counter uint64
}

// AsyncValidationContextMockValueParams contains parameters of the AsyncValidationContext.Value
type AsyncValidationContextMockValueParams struct {
	key interface{}
}

// AsyncValidationContextMockValueResults contains results of the AsyncValidationContext.Value
type AsyncValidationContextMockValueResults struct {
	p1 interface{}
}

// Expect sets up expected params for AsyncValidationContext.Value
func (mmValue *mAsyncValidationContextMockValue) Expect(key interface{}) *mAsyncValidationContextMockValue {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("AsyncValidationContextMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &AsyncValidationContextMockValueExpectation{}
	}

	mmValue.defaultExpectation.params = &AsyncValidationContextMockValueParams{key}
	for _, e := range mmValue.expectations {
		if minimock.Equal(e.params, mmValue.defaultExpectation.params) {
			mmValue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValue.defaultExpectation.params)
		}
	}

	return mmValue
}

// Inspect accepts an inspector function that has same arguments as the AsyncValidationContext.Value
func (mmValue *mAsyncValidationContextMockValue) Inspect(f func(key interface{})) *mAsyncValidationContextMockValue {
	if mmValue.mock.inspectFuncValue != nil {
		mmValue.mock.t.Fatalf("Inspect function is already set for AsyncValidationContextMock.Value")
	}

	mmValue.mock.inspectFuncValue = f

	return mmValue
}

// Return sets up results that will be returned by AsyncValidationContext.Value
func (mmValue *mAsyncValidationContextMockValue) Return(p1 interface{}) *AsyncValidationContextMock {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("AsyncValidationContextMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &AsyncValidationContextMockValueExpectation{mock: mmValue.mock}
	}
	mmValue.defaultExpectation.results = &AsyncValidationContextMockValueResults{p1}
	return mmValue.mock
}

//Set uses given function f to mock the AsyncValidationContext.Value method
func (mmValue *mAsyncValidationContextMockValue) Set(f func(key interface{}) (p1 interface{})) *AsyncValidationContextMock {
	if mmValue.defaultExpectation != nil {
		mmValue.mock.t.Fatalf("Default expectation is already set for the AsyncValidationContext.Value method")
	}

	if len(mmValue.expectations) > 0 {
		mmValue.mock.t.Fatalf("Some expectations are already set for the AsyncValidationContext.Value method")
	}

	mmValue.mock.funcValue = f
	return mmValue.mock
}

// When sets expectation for the AsyncValidationContext.Value which will trigger the result defined by the following
// Then helper
func (mmValue *mAsyncValidationContextMockValue) When(key interface{}) *AsyncValidationContextMockValueExpectation {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("AsyncValidationContextMock.Value mock is already set by Set")
	}

	expectation := &AsyncValidationContextMockValueExpectation{
		mock:   mmValue.mock,
		params: &AsyncValidationContextMockValueParams{key},
	}
	mmValue.expectations = append(mmValue.expectations, expectation)
	return expectation
}

// Then sets up AsyncValidationContext.Value return parameters for the expectation previously defined by the When method
func (e *AsyncValidationContextMockValueExpectation) Then(p1 interface{}) *AsyncValidationContextMock {
	e.results = &AsyncValidationContextMockValueResults{p1}
	return e.mock
}

// Value implements validation.AsyncValidationContext
func (mmValue *AsyncValidationContextMock) Value(key interface{}) (p1 interface{}) {
	mm_atomic.AddUint64(&mmValue.beforeValueCounter, 1)
	defer mm_atomic.AddUint64(&mmValue.afterValueCounter, 1)

	if mmValue.inspectFuncValue != nil {
		mmValue.inspectFuncValue(key)
	}

	mm_params := &AsyncValidationContextMockValueParams{key}

	// Record call args
	mmValue.ValueMock.mutex.Lock()
	mmValue.ValueMock.callArgs = append(mmValue.ValueMock.callArgs, mm_params)
	mmValue.ValueMock.mutex.Unlock()

	for _, e := range mmValue.ValueMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmValue.ValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValue.ValueMock.defaultExpectation.Counter, 1)
		mm_want := mmValue.ValueMock.defaultExpectation.params
		mm_got := AsyncValidationContextMockValueParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValue.t.Errorf("AsyncValidationContextMock.Value got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValue.ValueMock.defaultExpectation.results
		if mm_results == nil {
			mmValue.t.Fatal("No results are set for the AsyncValidationContextMock.Value")
		}
		return (*mm_results).p1
	}
	if mmValue.funcValue != nil {
		return mmValue.funcValue(key)
	}
	mmValue.t.Fatalf("Unexpected call to AsyncValidationContextMock.Value. %v", key)
	return
}

// ValueAfterCounter returns a count of finished AsyncValidationContextMock.Value invocations
func (mmValue *AsyncValidationContextMock) ValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.afterValueCounter)
}

// ValueBeforeCounter returns a count of AsyncValidationContextMock.Value invocations
func (mmValue *AsyncValidationContextMock) ValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.beforeValueCounter)
}

// Calls returns a list of arguments used in each call to AsyncValidationContextMock.Value.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValue *mAsyncValidationContextMockValue) Calls() []*AsyncValidationContextMockValueParams {
	mmValue.mutex.RLock()

	argCopy := make([]*AsyncValidationContextMockValueParams, len(mmValue.callArgs))
	copy(argCopy, mmValue.callArgs)

	mmValue.mutex.RUnlock()

	return argCopy
}

// MinimockValueDone returns true if the count of the Value invocations corresponds
// the number of defined expectations
func (m *AsyncValidationContextMock) MinimockValueDone() bool {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	return true
}

// MinimockValueInspect logs each unmet expectation
func (m *AsyncValidationContextMock) MinimockValueInspect() {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AsyncValidationContextMock.Value with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		if m.ValueMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AsyncValidationContextMock.Value")
		} else {
			m.t.Errorf("Expected call to AsyncValidationContextMock.Value with params: %#v", *m.ValueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		m.t.Error("Expected call to AsyncValidationContextMock.Value")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AsyncValidationContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockArgsInspect()

		m.MinimockDeadlineInspect()

		m.MinimockDoneInspect()

		m.MinimockErrInspect()

		m.MinimockFilesInspect()

		m.MinimockMessageInspect()

		m.MinimockOutputInspect()

		m.MinimockRepositoryInspect()

		m.MinimockShellInspect()

		m.MinimockStopInspect()

		m.MinimockValueInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AsyncValidationContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AsyncValidationContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArgsDone() &&
		m.MinimockDeadlineDone() &&
		m.MinimockDoneDone() &&
		m.MinimockErrDone() &&
		m.MinimockFilesDone() &&
		m.MinimockMessageDone() &&
		m.MinimockOutputDone() &&
		m.MinimockRepositoryDone() &&
		m.MinimockShellDone() &&
		m.MinimockStopDone() &&
		m.MinimockValueDone()
}
