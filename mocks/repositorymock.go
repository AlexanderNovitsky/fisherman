package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/infrastructure.Repository -o ./mocks\repositorymock.go

import (
	mm_infrastructure "fisherman/infrastructure"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements infrastructure.Repository
type RepositoryMock struct {
	t minimock.Tester

	funcAddGlob          func(glob string) (err error)
	inspectFuncAddGlob   func(glob string)
	afterAddGlobCounter  uint64
	beforeAddGlobCounter uint64
	AddGlobMock          mRepositoryMockAddGlob

	funcGetCurrentBranch          func() (s1 string, err error)
	inspectFuncGetCurrentBranch   func()
	afterGetCurrentBranchCounter  uint64
	beforeGetCurrentBranchCounter uint64
	GetCurrentBranchMock          mRepositoryMockGetCurrentBranch

	funcGetLastTag          func() (s1 string, err error)
	inspectFuncGetLastTag   func()
	afterGetLastTagCounter  uint64
	beforeGetLastTagCounter uint64
	GetLastTagMock          mRepositoryMockGetLastTag

	funcGetUser          func() (u1 mm_infrastructure.User, err error)
	inspectFuncGetUser   func()
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mRepositoryMockGetUser
}

// NewRepositoryMock returns a mock for infrastructure.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddGlobMock = mRepositoryMockAddGlob{mock: m}
	m.AddGlobMock.callArgs = []*RepositoryMockAddGlobParams{}

	m.GetCurrentBranchMock = mRepositoryMockGetCurrentBranch{mock: m}

	m.GetLastTagMock = mRepositoryMockGetLastTag{mock: m}

	m.GetUserMock = mRepositoryMockGetUser{mock: m}

	return m
}

type mRepositoryMockAddGlob struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddGlobExpectation
	expectations       []*RepositoryMockAddGlobExpectation

	callArgs []*RepositoryMockAddGlobParams
	mutex    sync.RWMutex
}

// RepositoryMockAddGlobExpectation specifies expectation struct of the Repository.AddGlob
type RepositoryMockAddGlobExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddGlobParams
	results *RepositoryMockAddGlobResults
	Counter uint64
}

// RepositoryMockAddGlobParams contains parameters of the Repository.AddGlob
type RepositoryMockAddGlobParams struct {
	glob string
}

// RepositoryMockAddGlobResults contains results of the Repository.AddGlob
type RepositoryMockAddGlobResults struct {
	err error
}

// Expect sets up expected params for Repository.AddGlob
func (mmAddGlob *mRepositoryMockAddGlob) Expect(glob string) *mRepositoryMockAddGlob {
	if mmAddGlob.mock.funcAddGlob != nil {
		mmAddGlob.mock.t.Fatalf("RepositoryMock.AddGlob mock is already set by Set")
	}

	if mmAddGlob.defaultExpectation == nil {
		mmAddGlob.defaultExpectation = &RepositoryMockAddGlobExpectation{}
	}

	mmAddGlob.defaultExpectation.params = &RepositoryMockAddGlobParams{glob}
	for _, e := range mmAddGlob.expectations {
		if minimock.Equal(e.params, mmAddGlob.defaultExpectation.params) {
			mmAddGlob.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddGlob.defaultExpectation.params)
		}
	}

	return mmAddGlob
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddGlob
func (mmAddGlob *mRepositoryMockAddGlob) Inspect(f func(glob string)) *mRepositoryMockAddGlob {
	if mmAddGlob.mock.inspectFuncAddGlob != nil {
		mmAddGlob.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddGlob")
	}

	mmAddGlob.mock.inspectFuncAddGlob = f

	return mmAddGlob
}

// Return sets up results that will be returned by Repository.AddGlob
func (mmAddGlob *mRepositoryMockAddGlob) Return(err error) *RepositoryMock {
	if mmAddGlob.mock.funcAddGlob != nil {
		mmAddGlob.mock.t.Fatalf("RepositoryMock.AddGlob mock is already set by Set")
	}

	if mmAddGlob.defaultExpectation == nil {
		mmAddGlob.defaultExpectation = &RepositoryMockAddGlobExpectation{mock: mmAddGlob.mock}
	}
	mmAddGlob.defaultExpectation.results = &RepositoryMockAddGlobResults{err}
	return mmAddGlob.mock
}

//Set uses given function f to mock the Repository.AddGlob method
func (mmAddGlob *mRepositoryMockAddGlob) Set(f func(glob string) (err error)) *RepositoryMock {
	if mmAddGlob.defaultExpectation != nil {
		mmAddGlob.mock.t.Fatalf("Default expectation is already set for the Repository.AddGlob method")
	}

	if len(mmAddGlob.expectations) > 0 {
		mmAddGlob.mock.t.Fatalf("Some expectations are already set for the Repository.AddGlob method")
	}

	mmAddGlob.mock.funcAddGlob = f
	return mmAddGlob.mock
}

// When sets expectation for the Repository.AddGlob which will trigger the result defined by the following
// Then helper
func (mmAddGlob *mRepositoryMockAddGlob) When(glob string) *RepositoryMockAddGlobExpectation {
	if mmAddGlob.mock.funcAddGlob != nil {
		mmAddGlob.mock.t.Fatalf("RepositoryMock.AddGlob mock is already set by Set")
	}

	expectation := &RepositoryMockAddGlobExpectation{
		mock:   mmAddGlob.mock,
		params: &RepositoryMockAddGlobParams{glob},
	}
	mmAddGlob.expectations = append(mmAddGlob.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddGlob return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddGlobExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddGlobResults{err}
	return e.mock
}

// AddGlob implements infrastructure.Repository
func (mmAddGlob *RepositoryMock) AddGlob(glob string) (err error) {
	mm_atomic.AddUint64(&mmAddGlob.beforeAddGlobCounter, 1)
	defer mm_atomic.AddUint64(&mmAddGlob.afterAddGlobCounter, 1)

	if mmAddGlob.inspectFuncAddGlob != nil {
		mmAddGlob.inspectFuncAddGlob(glob)
	}

	mm_params := &RepositoryMockAddGlobParams{glob}

	// Record call args
	mmAddGlob.AddGlobMock.mutex.Lock()
	mmAddGlob.AddGlobMock.callArgs = append(mmAddGlob.AddGlobMock.callArgs, mm_params)
	mmAddGlob.AddGlobMock.mutex.Unlock()

	for _, e := range mmAddGlob.AddGlobMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddGlob.AddGlobMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddGlob.AddGlobMock.defaultExpectation.Counter, 1)
		mm_want := mmAddGlob.AddGlobMock.defaultExpectation.params
		mm_got := RepositoryMockAddGlobParams{glob}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddGlob.t.Errorf("RepositoryMock.AddGlob got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddGlob.AddGlobMock.defaultExpectation.results
		if mm_results == nil {
			mmAddGlob.t.Fatal("No results are set for the RepositoryMock.AddGlob")
		}
		return (*mm_results).err
	}
	if mmAddGlob.funcAddGlob != nil {
		return mmAddGlob.funcAddGlob(glob)
	}
	mmAddGlob.t.Fatalf("Unexpected call to RepositoryMock.AddGlob. %v", glob)
	return
}

// AddGlobAfterCounter returns a count of finished RepositoryMock.AddGlob invocations
func (mmAddGlob *RepositoryMock) AddGlobAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddGlob.afterAddGlobCounter)
}

// AddGlobBeforeCounter returns a count of RepositoryMock.AddGlob invocations
func (mmAddGlob *RepositoryMock) AddGlobBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddGlob.beforeAddGlobCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddGlob.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddGlob *mRepositoryMockAddGlob) Calls() []*RepositoryMockAddGlobParams {
	mmAddGlob.mutex.RLock()

	argCopy := make([]*RepositoryMockAddGlobParams, len(mmAddGlob.callArgs))
	copy(argCopy, mmAddGlob.callArgs)

	mmAddGlob.mutex.RUnlock()

	return argCopy
}

// MinimockAddGlobDone returns true if the count of the AddGlob invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddGlobDone() bool {
	for _, e := range m.AddGlobMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddGlobMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddGlobCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddGlob != nil && mm_atomic.LoadUint64(&m.afterAddGlobCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddGlobInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddGlobInspect() {
	for _, e := range m.AddGlobMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddGlob with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddGlobMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddGlobCounter) < 1 {
		if m.AddGlobMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddGlob")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddGlob with params: %#v", *m.AddGlobMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddGlob != nil && mm_atomic.LoadUint64(&m.afterAddGlobCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddGlob")
	}
}

type mRepositoryMockGetCurrentBranch struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCurrentBranchExpectation
	expectations       []*RepositoryMockGetCurrentBranchExpectation
}

// RepositoryMockGetCurrentBranchExpectation specifies expectation struct of the Repository.GetCurrentBranch
type RepositoryMockGetCurrentBranchExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetCurrentBranchResults
	Counter uint64
}

// RepositoryMockGetCurrentBranchResults contains results of the Repository.GetCurrentBranch
type RepositoryMockGetCurrentBranchResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Expect() *mRepositoryMockGetCurrentBranch {
	if mmGetCurrentBranch.mock.funcGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("RepositoryMock.GetCurrentBranch mock is already set by Set")
	}

	if mmGetCurrentBranch.defaultExpectation == nil {
		mmGetCurrentBranch.defaultExpectation = &RepositoryMockGetCurrentBranchExpectation{}
	}

	return mmGetCurrentBranch
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Inspect(f func()) *mRepositoryMockGetCurrentBranch {
	if mmGetCurrentBranch.mock.inspectFuncGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCurrentBranch")
	}

	mmGetCurrentBranch.mock.inspectFuncGetCurrentBranch = f

	return mmGetCurrentBranch
}

// Return sets up results that will be returned by Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Return(s1 string, err error) *RepositoryMock {
	if mmGetCurrentBranch.mock.funcGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("RepositoryMock.GetCurrentBranch mock is already set by Set")
	}

	if mmGetCurrentBranch.defaultExpectation == nil {
		mmGetCurrentBranch.defaultExpectation = &RepositoryMockGetCurrentBranchExpectation{mock: mmGetCurrentBranch.mock}
	}
	mmGetCurrentBranch.defaultExpectation.results = &RepositoryMockGetCurrentBranchResults{s1, err}
	return mmGetCurrentBranch.mock
}

//Set uses given function f to mock the Repository.GetCurrentBranch method
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Set(f func() (s1 string, err error)) *RepositoryMock {
	if mmGetCurrentBranch.defaultExpectation != nil {
		mmGetCurrentBranch.mock.t.Fatalf("Default expectation is already set for the Repository.GetCurrentBranch method")
	}

	if len(mmGetCurrentBranch.expectations) > 0 {
		mmGetCurrentBranch.mock.t.Fatalf("Some expectations are already set for the Repository.GetCurrentBranch method")
	}

	mmGetCurrentBranch.mock.funcGetCurrentBranch = f
	return mmGetCurrentBranch.mock
}

// GetCurrentBranch implements infrastructure.Repository
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranch() (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetCurrentBranch.beforeGetCurrentBranchCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCurrentBranch.afterGetCurrentBranchCounter, 1)

	if mmGetCurrentBranch.inspectFuncGetCurrentBranch != nil {
		mmGetCurrentBranch.inspectFuncGetCurrentBranch()
	}

	if mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation.Counter, 1)

		mm_results := mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCurrentBranch.t.Fatal("No results are set for the RepositoryMock.GetCurrentBranch")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetCurrentBranch.funcGetCurrentBranch != nil {
		return mmGetCurrentBranch.funcGetCurrentBranch()
	}
	mmGetCurrentBranch.t.Fatalf("Unexpected call to RepositoryMock.GetCurrentBranch.")
	return
}

// GetCurrentBranchAfterCounter returns a count of finished RepositoryMock.GetCurrentBranch invocations
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCurrentBranch.afterGetCurrentBranchCounter)
}

// GetCurrentBranchBeforeCounter returns a count of RepositoryMock.GetCurrentBranch invocations
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCurrentBranch.beforeGetCurrentBranchCounter)
}

// MinimockGetCurrentBranchDone returns true if the count of the GetCurrentBranch invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCurrentBranchDone() bool {
	for _, e := range m.GetCurrentBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCurrentBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCurrentBranch != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCurrentBranchInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCurrentBranchInspect() {
	for _, e := range m.GetCurrentBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCurrentBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCurrentBranch != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
	}
}

type mRepositoryMockGetLastTag struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLastTagExpectation
	expectations       []*RepositoryMockGetLastTagExpectation
}

// RepositoryMockGetLastTagExpectation specifies expectation struct of the Repository.GetLastTag
type RepositoryMockGetLastTagExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetLastTagResults
	Counter uint64
}

// RepositoryMockGetLastTagResults contains results of the Repository.GetLastTag
type RepositoryMockGetLastTagResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Expect() *mRepositoryMockGetLastTag {
	if mmGetLastTag.mock.funcGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("RepositoryMock.GetLastTag mock is already set by Set")
	}

	if mmGetLastTag.defaultExpectation == nil {
		mmGetLastTag.defaultExpectation = &RepositoryMockGetLastTagExpectation{}
	}

	return mmGetLastTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Inspect(f func()) *mRepositoryMockGetLastTag {
	if mmGetLastTag.mock.inspectFuncGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLastTag")
	}

	mmGetLastTag.mock.inspectFuncGetLastTag = f

	return mmGetLastTag
}

// Return sets up results that will be returned by Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Return(s1 string, err error) *RepositoryMock {
	if mmGetLastTag.mock.funcGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("RepositoryMock.GetLastTag mock is already set by Set")
	}

	if mmGetLastTag.defaultExpectation == nil {
		mmGetLastTag.defaultExpectation = &RepositoryMockGetLastTagExpectation{mock: mmGetLastTag.mock}
	}
	mmGetLastTag.defaultExpectation.results = &RepositoryMockGetLastTagResults{s1, err}
	return mmGetLastTag.mock
}

//Set uses given function f to mock the Repository.GetLastTag method
func (mmGetLastTag *mRepositoryMockGetLastTag) Set(f func() (s1 string, err error)) *RepositoryMock {
	if mmGetLastTag.defaultExpectation != nil {
		mmGetLastTag.mock.t.Fatalf("Default expectation is already set for the Repository.GetLastTag method")
	}

	if len(mmGetLastTag.expectations) > 0 {
		mmGetLastTag.mock.t.Fatalf("Some expectations are already set for the Repository.GetLastTag method")
	}

	mmGetLastTag.mock.funcGetLastTag = f
	return mmGetLastTag.mock
}

// GetLastTag implements infrastructure.Repository
func (mmGetLastTag *RepositoryMock) GetLastTag() (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetLastTag.beforeGetLastTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLastTag.afterGetLastTagCounter, 1)

	if mmGetLastTag.inspectFuncGetLastTag != nil {
		mmGetLastTag.inspectFuncGetLastTag()
	}

	if mmGetLastTag.GetLastTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLastTag.GetLastTagMock.defaultExpectation.Counter, 1)

		mm_results := mmGetLastTag.GetLastTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLastTag.t.Fatal("No results are set for the RepositoryMock.GetLastTag")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetLastTag.funcGetLastTag != nil {
		return mmGetLastTag.funcGetLastTag()
	}
	mmGetLastTag.t.Fatalf("Unexpected call to RepositoryMock.GetLastTag.")
	return
}

// GetLastTagAfterCounter returns a count of finished RepositoryMock.GetLastTag invocations
func (mmGetLastTag *RepositoryMock) GetLastTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastTag.afterGetLastTagCounter)
}

// GetLastTagBeforeCounter returns a count of RepositoryMock.GetLastTag invocations
func (mmGetLastTag *RepositoryMock) GetLastTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastTag.beforeGetLastTagCounter)
}

// MinimockGetLastTagDone returns true if the count of the GetLastTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLastTagDone() bool {
	for _, e := range m.GetLastTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastTag != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetLastTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLastTagInspect() {
	for _, e := range m.GetLastTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetLastTag")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLastTag")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastTag != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLastTag")
	}
}

type mRepositoryMockGetUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserExpectation
	expectations       []*RepositoryMockGetUserExpectation
}

// RepositoryMockGetUserExpectation specifies expectation struct of the Repository.GetUser
type RepositoryMockGetUserExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetUserResults
	Counter uint64
}

// RepositoryMockGetUserResults contains results of the Repository.GetUser
type RepositoryMockGetUserResults struct {
	u1  mm_infrastructure.User
	err error
}

// Expect sets up expected params for Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Expect() *mRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{}
	}

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Inspect(f func()) *mRepositoryMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Return(u1 mm_infrastructure.User, err error) *RepositoryMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &RepositoryMockGetUserResults{u1, err}
	return mmGetUser.mock
}

//Set uses given function f to mock the Repository.GetUser method
func (mmGetUser *mRepositoryMockGetUser) Set(f func() (u1 mm_infrastructure.User, err error)) *RepositoryMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Repository.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Repository.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// GetUser implements infrastructure.Repository
func (mmGetUser *RepositoryMock) GetUser() (u1 mm_infrastructure.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser()
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the RepositoryMock.GetUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser()
	}
	mmGetUser.t.Fatalf("Unexpected call to RepositoryMock.GetUser.")
	return
}

// GetUserAfterCounter returns a count of finished RepositoryMock.GetUser invocations
func (mmGetUser *RepositoryMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of RepositoryMock.GetUser invocations
func (mmGetUser *RepositoryMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserDone() bool {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetUser")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUser")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddGlobInspect()

		m.MinimockGetCurrentBranchInspect()

		m.MinimockGetLastTagInspect()

		m.MinimockGetUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddGlobDone() &&
		m.MinimockGetCurrentBranchDone() &&
		m.MinimockGetLastTagDone() &&
		m.MinimockGetUserDone()
}
