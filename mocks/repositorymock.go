package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/infrastructure.Repository -o ./mocks\repositorymock.go

import (
	mm_infrastructure "fisherman/infrastructure"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements infrastructure.Repository
type RepositoryMock struct {
	t minimock.Tester

	funcGetCurrentBranch          func() (s1 string, err error)
	inspectFuncGetCurrentBranch   func()
	afterGetCurrentBranchCounter  uint64
	beforeGetCurrentBranchCounter uint64
	GetCurrentBranchMock          mRepositoryMockGetCurrentBranch

	funcGetLastTag          func() (s1 string, err error)
	inspectFuncGetLastTag   func()
	afterGetLastTagCounter  uint64
	beforeGetLastTagCounter uint64
	GetLastTagMock          mRepositoryMockGetLastTag

	funcGetUser          func() (u1 mm_infrastructure.User, err error)
	inspectFuncGetUser   func()
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mRepositoryMockGetUser
}

// NewRepositoryMock returns a mock for infrastructure.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCurrentBranchMock = mRepositoryMockGetCurrentBranch{mock: m}

	m.GetLastTagMock = mRepositoryMockGetLastTag{mock: m}

	m.GetUserMock = mRepositoryMockGetUser{mock: m}

	return m
}

type mRepositoryMockGetCurrentBranch struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCurrentBranchExpectation
	expectations       []*RepositoryMockGetCurrentBranchExpectation
}

// RepositoryMockGetCurrentBranchExpectation specifies expectation struct of the Repository.GetCurrentBranch
type RepositoryMockGetCurrentBranchExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetCurrentBranchResults
	Counter uint64
}

// RepositoryMockGetCurrentBranchResults contains results of the Repository.GetCurrentBranch
type RepositoryMockGetCurrentBranchResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Expect() *mRepositoryMockGetCurrentBranch {
	if mmGetCurrentBranch.mock.funcGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("RepositoryMock.GetCurrentBranch mock is already set by Set")
	}

	if mmGetCurrentBranch.defaultExpectation == nil {
		mmGetCurrentBranch.defaultExpectation = &RepositoryMockGetCurrentBranchExpectation{}
	}

	return mmGetCurrentBranch
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Inspect(f func()) *mRepositoryMockGetCurrentBranch {
	if mmGetCurrentBranch.mock.inspectFuncGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCurrentBranch")
	}

	mmGetCurrentBranch.mock.inspectFuncGetCurrentBranch = f

	return mmGetCurrentBranch
}

// Return sets up results that will be returned by Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Return(s1 string, err error) *RepositoryMock {
	if mmGetCurrentBranch.mock.funcGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("RepositoryMock.GetCurrentBranch mock is already set by Set")
	}

	if mmGetCurrentBranch.defaultExpectation == nil {
		mmGetCurrentBranch.defaultExpectation = &RepositoryMockGetCurrentBranchExpectation{mock: mmGetCurrentBranch.mock}
	}
	mmGetCurrentBranch.defaultExpectation.results = &RepositoryMockGetCurrentBranchResults{s1, err}
	return mmGetCurrentBranch.mock
}

//Set uses given function f to mock the Repository.GetCurrentBranch method
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Set(f func() (s1 string, err error)) *RepositoryMock {
	if mmGetCurrentBranch.defaultExpectation != nil {
		mmGetCurrentBranch.mock.t.Fatalf("Default expectation is already set for the Repository.GetCurrentBranch method")
	}

	if len(mmGetCurrentBranch.expectations) > 0 {
		mmGetCurrentBranch.mock.t.Fatalf("Some expectations are already set for the Repository.GetCurrentBranch method")
	}

	mmGetCurrentBranch.mock.funcGetCurrentBranch = f
	return mmGetCurrentBranch.mock
}

// GetCurrentBranch implements infrastructure.Repository
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranch() (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetCurrentBranch.beforeGetCurrentBranchCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCurrentBranch.afterGetCurrentBranchCounter, 1)

	if mmGetCurrentBranch.inspectFuncGetCurrentBranch != nil {
		mmGetCurrentBranch.inspectFuncGetCurrentBranch()
	}

	if mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation.Counter, 1)

		mm_results := mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCurrentBranch.t.Fatal("No results are set for the RepositoryMock.GetCurrentBranch")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetCurrentBranch.funcGetCurrentBranch != nil {
		return mmGetCurrentBranch.funcGetCurrentBranch()
	}
	mmGetCurrentBranch.t.Fatalf("Unexpected call to RepositoryMock.GetCurrentBranch.")
	return
}

// GetCurrentBranchAfterCounter returns a count of finished RepositoryMock.GetCurrentBranch invocations
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCurrentBranch.afterGetCurrentBranchCounter)
}

// GetCurrentBranchBeforeCounter returns a count of RepositoryMock.GetCurrentBranch invocations
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCurrentBranch.beforeGetCurrentBranchCounter)
}

// MinimockGetCurrentBranchDone returns true if the count of the GetCurrentBranch invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCurrentBranchDone() bool {
	for _, e := range m.GetCurrentBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCurrentBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCurrentBranch != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCurrentBranchInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCurrentBranchInspect() {
	for _, e := range m.GetCurrentBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCurrentBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCurrentBranch != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
	}
}

type mRepositoryMockGetLastTag struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLastTagExpectation
	expectations       []*RepositoryMockGetLastTagExpectation
}

// RepositoryMockGetLastTagExpectation specifies expectation struct of the Repository.GetLastTag
type RepositoryMockGetLastTagExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetLastTagResults
	Counter uint64
}

// RepositoryMockGetLastTagResults contains results of the Repository.GetLastTag
type RepositoryMockGetLastTagResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Expect() *mRepositoryMockGetLastTag {
	if mmGetLastTag.mock.funcGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("RepositoryMock.GetLastTag mock is already set by Set")
	}

	if mmGetLastTag.defaultExpectation == nil {
		mmGetLastTag.defaultExpectation = &RepositoryMockGetLastTagExpectation{}
	}

	return mmGetLastTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Inspect(f func()) *mRepositoryMockGetLastTag {
	if mmGetLastTag.mock.inspectFuncGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLastTag")
	}

	mmGetLastTag.mock.inspectFuncGetLastTag = f

	return mmGetLastTag
}

// Return sets up results that will be returned by Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Return(s1 string, err error) *RepositoryMock {
	if mmGetLastTag.mock.funcGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("RepositoryMock.GetLastTag mock is already set by Set")
	}

	if mmGetLastTag.defaultExpectation == nil {
		mmGetLastTag.defaultExpectation = &RepositoryMockGetLastTagExpectation{mock: mmGetLastTag.mock}
	}
	mmGetLastTag.defaultExpectation.results = &RepositoryMockGetLastTagResults{s1, err}
	return mmGetLastTag.mock
}

//Set uses given function f to mock the Repository.GetLastTag method
func (mmGetLastTag *mRepositoryMockGetLastTag) Set(f func() (s1 string, err error)) *RepositoryMock {
	if mmGetLastTag.defaultExpectation != nil {
		mmGetLastTag.mock.t.Fatalf("Default expectation is already set for the Repository.GetLastTag method")
	}

	if len(mmGetLastTag.expectations) > 0 {
		mmGetLastTag.mock.t.Fatalf("Some expectations are already set for the Repository.GetLastTag method")
	}

	mmGetLastTag.mock.funcGetLastTag = f
	return mmGetLastTag.mock
}

// GetLastTag implements infrastructure.Repository
func (mmGetLastTag *RepositoryMock) GetLastTag() (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetLastTag.beforeGetLastTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLastTag.afterGetLastTagCounter, 1)

	if mmGetLastTag.inspectFuncGetLastTag != nil {
		mmGetLastTag.inspectFuncGetLastTag()
	}

	if mmGetLastTag.GetLastTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLastTag.GetLastTagMock.defaultExpectation.Counter, 1)

		mm_results := mmGetLastTag.GetLastTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLastTag.t.Fatal("No results are set for the RepositoryMock.GetLastTag")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetLastTag.funcGetLastTag != nil {
		return mmGetLastTag.funcGetLastTag()
	}
	mmGetLastTag.t.Fatalf("Unexpected call to RepositoryMock.GetLastTag.")
	return
}

// GetLastTagAfterCounter returns a count of finished RepositoryMock.GetLastTag invocations
func (mmGetLastTag *RepositoryMock) GetLastTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastTag.afterGetLastTagCounter)
}

// GetLastTagBeforeCounter returns a count of RepositoryMock.GetLastTag invocations
func (mmGetLastTag *RepositoryMock) GetLastTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastTag.beforeGetLastTagCounter)
}

// MinimockGetLastTagDone returns true if the count of the GetLastTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLastTagDone() bool {
	for _, e := range m.GetLastTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastTag != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetLastTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLastTagInspect() {
	for _, e := range m.GetLastTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetLastTag")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLastTag")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastTag != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLastTag")
	}
}

type mRepositoryMockGetUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserExpectation
	expectations       []*RepositoryMockGetUserExpectation
}

// RepositoryMockGetUserExpectation specifies expectation struct of the Repository.GetUser
type RepositoryMockGetUserExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetUserResults
	Counter uint64
}

// RepositoryMockGetUserResults contains results of the Repository.GetUser
type RepositoryMockGetUserResults struct {
	u1  mm_infrastructure.User
	err error
}

// Expect sets up expected params for Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Expect() *mRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{}
	}

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Inspect(f func()) *mRepositoryMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Return(u1 mm_infrastructure.User, err error) *RepositoryMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &RepositoryMockGetUserResults{u1, err}
	return mmGetUser.mock
}

//Set uses given function f to mock the Repository.GetUser method
func (mmGetUser *mRepositoryMockGetUser) Set(f func() (u1 mm_infrastructure.User, err error)) *RepositoryMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Repository.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Repository.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// GetUser implements infrastructure.Repository
func (mmGetUser *RepositoryMock) GetUser() (u1 mm_infrastructure.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser()
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the RepositoryMock.GetUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser()
	}
	mmGetUser.t.Fatalf("Unexpected call to RepositoryMock.GetUser.")
	return
}

// GetUserAfterCounter returns a count of finished RepositoryMock.GetUser invocations
func (mmGetUser *RepositoryMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of RepositoryMock.GetUser invocations
func (mmGetUser *RepositoryMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserDone() bool {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetUser")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUser")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetCurrentBranchInspect()

		m.MinimockGetLastTagInspect()

		m.MinimockGetUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCurrentBranchDone() &&
		m.MinimockGetLastTagDone() &&
		m.MinimockGetUserDone()
}
