package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/handlers/shellhandlers.ContextWithStop -o ./mocks\context_with_stopmock.go

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ContextWithStopMock implements shellhandlers.ContextWithStop
type ContextWithStopMock struct {
	t minimock.Tester

	funcDeadline          func() (deadline time.Time, ok bool)
	inspectFuncDeadline   func()
	afterDeadlineCounter  uint64
	beforeDeadlineCounter uint64
	DeadlineMock          mContextWithStopMockDeadline

	funcDone func() (ch1 <-chan struct {
	})
	inspectFuncDone   func()
	afterDoneCounter  uint64
	beforeDoneCounter uint64
	DoneMock          mContextWithStopMockDone

	funcErr          func() (err error)
	inspectFuncErr   func()
	afterErrCounter  uint64
	beforeErrCounter uint64
	ErrMock          mContextWithStopMockErr

	funcStop          func()
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mContextWithStopMockStop

	funcValue          func(key interface{}) (p1 interface{})
	inspectFuncValue   func(key interface{})
	afterValueCounter  uint64
	beforeValueCounter uint64
	ValueMock          mContextWithStopMockValue
}

// NewContextWithStopMock returns a mock for shellhandlers.ContextWithStop
func NewContextWithStopMock(t minimock.Tester) *ContextWithStopMock {
	m := &ContextWithStopMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeadlineMock = mContextWithStopMockDeadline{mock: m}

	m.DoneMock = mContextWithStopMockDone{mock: m}

	m.ErrMock = mContextWithStopMockErr{mock: m}

	m.StopMock = mContextWithStopMockStop{mock: m}

	m.ValueMock = mContextWithStopMockValue{mock: m}
	m.ValueMock.callArgs = []*ContextWithStopMockValueParams{}

	return m
}

type mContextWithStopMockDeadline struct {
	mock               *ContextWithStopMock
	defaultExpectation *ContextWithStopMockDeadlineExpectation
	expectations       []*ContextWithStopMockDeadlineExpectation
}

// ContextWithStopMockDeadlineExpectation specifies expectation struct of the ContextWithStop.Deadline
type ContextWithStopMockDeadlineExpectation struct {
	mock *ContextWithStopMock

	results *ContextWithStopMockDeadlineResults
	Counter uint64
}

// ContextWithStopMockDeadlineResults contains results of the ContextWithStop.Deadline
type ContextWithStopMockDeadlineResults struct {
	deadline time.Time
	ok       bool
}

// Expect sets up expected params for ContextWithStop.Deadline
func (mmDeadline *mContextWithStopMockDeadline) Expect() *mContextWithStopMockDeadline {
	if mmDeadline.mock.funcDeadline != nil {
		mmDeadline.mock.t.Fatalf("ContextWithStopMock.Deadline mock is already set by Set")
	}

	if mmDeadline.defaultExpectation == nil {
		mmDeadline.defaultExpectation = &ContextWithStopMockDeadlineExpectation{}
	}

	return mmDeadline
}

// Inspect accepts an inspector function that has same arguments as the ContextWithStop.Deadline
func (mmDeadline *mContextWithStopMockDeadline) Inspect(f func()) *mContextWithStopMockDeadline {
	if mmDeadline.mock.inspectFuncDeadline != nil {
		mmDeadline.mock.t.Fatalf("Inspect function is already set for ContextWithStopMock.Deadline")
	}

	mmDeadline.mock.inspectFuncDeadline = f

	return mmDeadline
}

// Return sets up results that will be returned by ContextWithStop.Deadline
func (mmDeadline *mContextWithStopMockDeadline) Return(deadline time.Time, ok bool) *ContextWithStopMock {
	if mmDeadline.mock.funcDeadline != nil {
		mmDeadline.mock.t.Fatalf("ContextWithStopMock.Deadline mock is already set by Set")
	}

	if mmDeadline.defaultExpectation == nil {
		mmDeadline.defaultExpectation = &ContextWithStopMockDeadlineExpectation{mock: mmDeadline.mock}
	}
	mmDeadline.defaultExpectation.results = &ContextWithStopMockDeadlineResults{deadline, ok}
	return mmDeadline.mock
}

//Set uses given function f to mock the ContextWithStop.Deadline method
func (mmDeadline *mContextWithStopMockDeadline) Set(f func() (deadline time.Time, ok bool)) *ContextWithStopMock {
	if mmDeadline.defaultExpectation != nil {
		mmDeadline.mock.t.Fatalf("Default expectation is already set for the ContextWithStop.Deadline method")
	}

	if len(mmDeadline.expectations) > 0 {
		mmDeadline.mock.t.Fatalf("Some expectations are already set for the ContextWithStop.Deadline method")
	}

	mmDeadline.mock.funcDeadline = f
	return mmDeadline.mock
}

// Deadline implements shellhandlers.ContextWithStop
func (mmDeadline *ContextWithStopMock) Deadline() (deadline time.Time, ok bool) {
	mm_atomic.AddUint64(&mmDeadline.beforeDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmDeadline.afterDeadlineCounter, 1)

	if mmDeadline.inspectFuncDeadline != nil {
		mmDeadline.inspectFuncDeadline()
	}

	if mmDeadline.DeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeadline.DeadlineMock.defaultExpectation.Counter, 1)

		mm_results := mmDeadline.DeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmDeadline.t.Fatal("No results are set for the ContextWithStopMock.Deadline")
		}
		return (*mm_results).deadline, (*mm_results).ok
	}
	if mmDeadline.funcDeadline != nil {
		return mmDeadline.funcDeadline()
	}
	mmDeadline.t.Fatalf("Unexpected call to ContextWithStopMock.Deadline.")
	return
}

// DeadlineAfterCounter returns a count of finished ContextWithStopMock.Deadline invocations
func (mmDeadline *ContextWithStopMock) DeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeadline.afterDeadlineCounter)
}

// DeadlineBeforeCounter returns a count of ContextWithStopMock.Deadline invocations
func (mmDeadline *ContextWithStopMock) DeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeadline.beforeDeadlineCounter)
}

// MinimockDeadlineDone returns true if the count of the Deadline invocations corresponds
// the number of defined expectations
func (m *ContextWithStopMock) MinimockDeadlineDone() bool {
	for _, e := range m.DeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeadline != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeadlineInspect logs each unmet expectation
func (m *ContextWithStopMock) MinimockDeadlineInspect() {
	for _, e := range m.DeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContextWithStopMock.Deadline")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Deadline")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeadline != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Deadline")
	}
}

type mContextWithStopMockDone struct {
	mock               *ContextWithStopMock
	defaultExpectation *ContextWithStopMockDoneExpectation
	expectations       []*ContextWithStopMockDoneExpectation
}

// ContextWithStopMockDoneExpectation specifies expectation struct of the ContextWithStop.Done
type ContextWithStopMockDoneExpectation struct {
	mock *ContextWithStopMock

	results *ContextWithStopMockDoneResults
	Counter uint64
}

// ContextWithStopMockDoneResults contains results of the ContextWithStop.Done
type ContextWithStopMockDoneResults struct {
	ch1 <-chan struct {
	}
}

// Expect sets up expected params for ContextWithStop.Done
func (mmDone *mContextWithStopMockDone) Expect() *mContextWithStopMockDone {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ContextWithStopMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &ContextWithStopMockDoneExpectation{}
	}

	return mmDone
}

// Inspect accepts an inspector function that has same arguments as the ContextWithStop.Done
func (mmDone *mContextWithStopMockDone) Inspect(f func()) *mContextWithStopMockDone {
	if mmDone.mock.inspectFuncDone != nil {
		mmDone.mock.t.Fatalf("Inspect function is already set for ContextWithStopMock.Done")
	}

	mmDone.mock.inspectFuncDone = f

	return mmDone
}

// Return sets up results that will be returned by ContextWithStop.Done
func (mmDone *mContextWithStopMockDone) Return(ch1 <-chan struct {
}) *ContextWithStopMock {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ContextWithStopMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &ContextWithStopMockDoneExpectation{mock: mmDone.mock}
	}
	mmDone.defaultExpectation.results = &ContextWithStopMockDoneResults{ch1}
	return mmDone.mock
}

//Set uses given function f to mock the ContextWithStop.Done method
func (mmDone *mContextWithStopMockDone) Set(f func() (ch1 <-chan struct {
})) *ContextWithStopMock {
	if mmDone.defaultExpectation != nil {
		mmDone.mock.t.Fatalf("Default expectation is already set for the ContextWithStop.Done method")
	}

	if len(mmDone.expectations) > 0 {
		mmDone.mock.t.Fatalf("Some expectations are already set for the ContextWithStop.Done method")
	}

	mmDone.mock.funcDone = f
	return mmDone.mock
}

// Done implements shellhandlers.ContextWithStop
func (mmDone *ContextWithStopMock) Done() (ch1 <-chan struct {
}) {
	mm_atomic.AddUint64(&mmDone.beforeDoneCounter, 1)
	defer mm_atomic.AddUint64(&mmDone.afterDoneCounter, 1)

	if mmDone.inspectFuncDone != nil {
		mmDone.inspectFuncDone()
	}

	if mmDone.DoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDone.DoneMock.defaultExpectation.Counter, 1)

		mm_results := mmDone.DoneMock.defaultExpectation.results
		if mm_results == nil {
			mmDone.t.Fatal("No results are set for the ContextWithStopMock.Done")
		}
		return (*mm_results).ch1
	}
	if mmDone.funcDone != nil {
		return mmDone.funcDone()
	}
	mmDone.t.Fatalf("Unexpected call to ContextWithStopMock.Done.")
	return
}

// DoneAfterCounter returns a count of finished ContextWithStopMock.Done invocations
func (mmDone *ContextWithStopMock) DoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.afterDoneCounter)
}

// DoneBeforeCounter returns a count of ContextWithStopMock.Done invocations
func (mmDone *ContextWithStopMock) DoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.beforeDoneCounter)
}

// MinimockDoneDone returns true if the count of the Done invocations corresponds
// the number of defined expectations
func (m *ContextWithStopMock) MinimockDoneDone() bool {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoneInspect logs each unmet expectation
func (m *ContextWithStopMock) MinimockDoneInspect() {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContextWithStopMock.Done")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Done")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Done")
	}
}

type mContextWithStopMockErr struct {
	mock               *ContextWithStopMock
	defaultExpectation *ContextWithStopMockErrExpectation
	expectations       []*ContextWithStopMockErrExpectation
}

// ContextWithStopMockErrExpectation specifies expectation struct of the ContextWithStop.Err
type ContextWithStopMockErrExpectation struct {
	mock *ContextWithStopMock

	results *ContextWithStopMockErrResults
	Counter uint64
}

// ContextWithStopMockErrResults contains results of the ContextWithStop.Err
type ContextWithStopMockErrResults struct {
	err error
}

// Expect sets up expected params for ContextWithStop.Err
func (mmErr *mContextWithStopMockErr) Expect() *mContextWithStopMockErr {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("ContextWithStopMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &ContextWithStopMockErrExpectation{}
	}

	return mmErr
}

// Inspect accepts an inspector function that has same arguments as the ContextWithStop.Err
func (mmErr *mContextWithStopMockErr) Inspect(f func()) *mContextWithStopMockErr {
	if mmErr.mock.inspectFuncErr != nil {
		mmErr.mock.t.Fatalf("Inspect function is already set for ContextWithStopMock.Err")
	}

	mmErr.mock.inspectFuncErr = f

	return mmErr
}

// Return sets up results that will be returned by ContextWithStop.Err
func (mmErr *mContextWithStopMockErr) Return(err error) *ContextWithStopMock {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("ContextWithStopMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &ContextWithStopMockErrExpectation{mock: mmErr.mock}
	}
	mmErr.defaultExpectation.results = &ContextWithStopMockErrResults{err}
	return mmErr.mock
}

//Set uses given function f to mock the ContextWithStop.Err method
func (mmErr *mContextWithStopMockErr) Set(f func() (err error)) *ContextWithStopMock {
	if mmErr.defaultExpectation != nil {
		mmErr.mock.t.Fatalf("Default expectation is already set for the ContextWithStop.Err method")
	}

	if len(mmErr.expectations) > 0 {
		mmErr.mock.t.Fatalf("Some expectations are already set for the ContextWithStop.Err method")
	}

	mmErr.mock.funcErr = f
	return mmErr.mock
}

// Err implements shellhandlers.ContextWithStop
func (mmErr *ContextWithStopMock) Err() (err error) {
	mm_atomic.AddUint64(&mmErr.beforeErrCounter, 1)
	defer mm_atomic.AddUint64(&mmErr.afterErrCounter, 1)

	if mmErr.inspectFuncErr != nil {
		mmErr.inspectFuncErr()
	}

	if mmErr.ErrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErr.ErrMock.defaultExpectation.Counter, 1)

		mm_results := mmErr.ErrMock.defaultExpectation.results
		if mm_results == nil {
			mmErr.t.Fatal("No results are set for the ContextWithStopMock.Err")
		}
		return (*mm_results).err
	}
	if mmErr.funcErr != nil {
		return mmErr.funcErr()
	}
	mmErr.t.Fatalf("Unexpected call to ContextWithStopMock.Err.")
	return
}

// ErrAfterCounter returns a count of finished ContextWithStopMock.Err invocations
func (mmErr *ContextWithStopMock) ErrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.afterErrCounter)
}

// ErrBeforeCounter returns a count of ContextWithStopMock.Err invocations
func (mmErr *ContextWithStopMock) ErrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.beforeErrCounter)
}

// MinimockErrDone returns true if the count of the Err invocations corresponds
// the number of defined expectations
func (m *ContextWithStopMock) MinimockErrDone() bool {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrInspect logs each unmet expectation
func (m *ContextWithStopMock) MinimockErrInspect() {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContextWithStopMock.Err")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Err")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Err")
	}
}

type mContextWithStopMockStop struct {
	mock               *ContextWithStopMock
	defaultExpectation *ContextWithStopMockStopExpectation
	expectations       []*ContextWithStopMockStopExpectation
}

// ContextWithStopMockStopExpectation specifies expectation struct of the ContextWithStop.Stop
type ContextWithStopMockStopExpectation struct {
	mock *ContextWithStopMock

	Counter uint64
}

// Expect sets up expected params for ContextWithStop.Stop
func (mmStop *mContextWithStopMockStop) Expect() *mContextWithStopMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("ContextWithStopMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &ContextWithStopMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the ContextWithStop.Stop
func (mmStop *mContextWithStopMockStop) Inspect(f func()) *mContextWithStopMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for ContextWithStopMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by ContextWithStop.Stop
func (mmStop *mContextWithStopMockStop) Return() *ContextWithStopMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("ContextWithStopMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &ContextWithStopMockStopExpectation{mock: mmStop.mock}
	}

	return mmStop.mock
}

//Set uses given function f to mock the ContextWithStop.Stop method
func (mmStop *mContextWithStopMockStop) Set(f func()) *ContextWithStopMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the ContextWithStop.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the ContextWithStop.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// Stop implements shellhandlers.ContextWithStop
func (mmStop *ContextWithStopMock) Stop() {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		return

	}
	if mmStop.funcStop != nil {
		mmStop.funcStop()
		return
	}
	mmStop.t.Fatalf("Unexpected call to ContextWithStopMock.Stop.")

}

// StopAfterCounter returns a count of finished ContextWithStopMock.Stop invocations
func (mmStop *ContextWithStopMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of ContextWithStopMock.Stop invocations
func (mmStop *ContextWithStopMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *ContextWithStopMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *ContextWithStopMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContextWithStopMock.Stop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Stop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Stop")
	}
}

type mContextWithStopMockValue struct {
	mock               *ContextWithStopMock
	defaultExpectation *ContextWithStopMockValueExpectation
	expectations       []*ContextWithStopMockValueExpectation

	callArgs []*ContextWithStopMockValueParams
	mutex    sync.RWMutex
}

// ContextWithStopMockValueExpectation specifies expectation struct of the ContextWithStop.Value
type ContextWithStopMockValueExpectation struct {
	mock    *ContextWithStopMock
	params  *ContextWithStopMockValueParams
	results *ContextWithStopMockValueResults
	Counter uint64
}

// ContextWithStopMockValueParams contains parameters of the ContextWithStop.Value
type ContextWithStopMockValueParams struct {
	key interface{}
}

// ContextWithStopMockValueResults contains results of the ContextWithStop.Value
type ContextWithStopMockValueResults struct {
	p1 interface{}
}

// Expect sets up expected params for ContextWithStop.Value
func (mmValue *mContextWithStopMockValue) Expect(key interface{}) *mContextWithStopMockValue {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ContextWithStopMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ContextWithStopMockValueExpectation{}
	}

	mmValue.defaultExpectation.params = &ContextWithStopMockValueParams{key}
	for _, e := range mmValue.expectations {
		if minimock.Equal(e.params, mmValue.defaultExpectation.params) {
			mmValue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValue.defaultExpectation.params)
		}
	}

	return mmValue
}

// Inspect accepts an inspector function that has same arguments as the ContextWithStop.Value
func (mmValue *mContextWithStopMockValue) Inspect(f func(key interface{})) *mContextWithStopMockValue {
	if mmValue.mock.inspectFuncValue != nil {
		mmValue.mock.t.Fatalf("Inspect function is already set for ContextWithStopMock.Value")
	}

	mmValue.mock.inspectFuncValue = f

	return mmValue
}

// Return sets up results that will be returned by ContextWithStop.Value
func (mmValue *mContextWithStopMockValue) Return(p1 interface{}) *ContextWithStopMock {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ContextWithStopMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &ContextWithStopMockValueExpectation{mock: mmValue.mock}
	}
	mmValue.defaultExpectation.results = &ContextWithStopMockValueResults{p1}
	return mmValue.mock
}

//Set uses given function f to mock the ContextWithStop.Value method
func (mmValue *mContextWithStopMockValue) Set(f func(key interface{}) (p1 interface{})) *ContextWithStopMock {
	if mmValue.defaultExpectation != nil {
		mmValue.mock.t.Fatalf("Default expectation is already set for the ContextWithStop.Value method")
	}

	if len(mmValue.expectations) > 0 {
		mmValue.mock.t.Fatalf("Some expectations are already set for the ContextWithStop.Value method")
	}

	mmValue.mock.funcValue = f
	return mmValue.mock
}

// When sets expectation for the ContextWithStop.Value which will trigger the result defined by the following
// Then helper
func (mmValue *mContextWithStopMockValue) When(key interface{}) *ContextWithStopMockValueExpectation {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("ContextWithStopMock.Value mock is already set by Set")
	}

	expectation := &ContextWithStopMockValueExpectation{
		mock:   mmValue.mock,
		params: &ContextWithStopMockValueParams{key},
	}
	mmValue.expectations = append(mmValue.expectations, expectation)
	return expectation
}

// Then sets up ContextWithStop.Value return parameters for the expectation previously defined by the When method
func (e *ContextWithStopMockValueExpectation) Then(p1 interface{}) *ContextWithStopMock {
	e.results = &ContextWithStopMockValueResults{p1}
	return e.mock
}

// Value implements shellhandlers.ContextWithStop
func (mmValue *ContextWithStopMock) Value(key interface{}) (p1 interface{}) {
	mm_atomic.AddUint64(&mmValue.beforeValueCounter, 1)
	defer mm_atomic.AddUint64(&mmValue.afterValueCounter, 1)

	if mmValue.inspectFuncValue != nil {
		mmValue.inspectFuncValue(key)
	}

	mm_params := &ContextWithStopMockValueParams{key}

	// Record call args
	mmValue.ValueMock.mutex.Lock()
	mmValue.ValueMock.callArgs = append(mmValue.ValueMock.callArgs, mm_params)
	mmValue.ValueMock.mutex.Unlock()

	for _, e := range mmValue.ValueMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmValue.ValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValue.ValueMock.defaultExpectation.Counter, 1)
		mm_want := mmValue.ValueMock.defaultExpectation.params
		mm_got := ContextWithStopMockValueParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValue.t.Errorf("ContextWithStopMock.Value got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValue.ValueMock.defaultExpectation.results
		if mm_results == nil {
			mmValue.t.Fatal("No results are set for the ContextWithStopMock.Value")
		}
		return (*mm_results).p1
	}
	if mmValue.funcValue != nil {
		return mmValue.funcValue(key)
	}
	mmValue.t.Fatalf("Unexpected call to ContextWithStopMock.Value. %v", key)
	return
}

// ValueAfterCounter returns a count of finished ContextWithStopMock.Value invocations
func (mmValue *ContextWithStopMock) ValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.afterValueCounter)
}

// ValueBeforeCounter returns a count of ContextWithStopMock.Value invocations
func (mmValue *ContextWithStopMock) ValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.beforeValueCounter)
}

// Calls returns a list of arguments used in each call to ContextWithStopMock.Value.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValue *mContextWithStopMockValue) Calls() []*ContextWithStopMockValueParams {
	mmValue.mutex.RLock()

	argCopy := make([]*ContextWithStopMockValueParams, len(mmValue.callArgs))
	copy(argCopy, mmValue.callArgs)

	mmValue.mutex.RUnlock()

	return argCopy
}

// MinimockValueDone returns true if the count of the Value invocations corresponds
// the number of defined expectations
func (m *ContextWithStopMock) MinimockValueDone() bool {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	return true
}

// MinimockValueInspect logs each unmet expectation
func (m *ContextWithStopMock) MinimockValueInspect() {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextWithStopMock.Value with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		if m.ValueMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContextWithStopMock.Value")
		} else {
			m.t.Errorf("Expected call to ContextWithStopMock.Value with params: %#v", *m.ValueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		m.t.Error("Expected call to ContextWithStopMock.Value")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContextWithStopMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeadlineInspect()

		m.MinimockDoneInspect()

		m.MinimockErrInspect()

		m.MinimockStopInspect()

		m.MinimockValueInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContextWithStopMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContextWithStopMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeadlineDone() &&
		m.MinimockDoneDone() &&
		m.MinimockErrDone() &&
		m.MinimockStopDone() &&
		m.MinimockValueDone()
}
