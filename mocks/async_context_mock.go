package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/internal.AsyncContext -o ./mocks/async_context_mock.go

import (
	"fisherman/infrastructure"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AsyncContextMock implements internal.AsyncContext
type AsyncContextMock struct {
	t minimock.Tester

	funcArgs          func() (sa1 []string)
	inspectFuncArgs   func()
	afterArgsCounter  uint64
	beforeArgsCounter uint64
	ArgsMock          mAsyncContextMockArgs

	funcDeadline          func() (deadline time.Time, ok bool)
	inspectFuncDeadline   func()
	afterDeadlineCounter  uint64
	beforeDeadlineCounter uint64
	DeadlineMock          mAsyncContextMockDeadline

	funcDone func() (ch1 <-chan struct {
	})
	inspectFuncDone   func()
	afterDoneCounter  uint64
	beforeDoneCounter uint64
	DoneMock          mAsyncContextMockDone

	funcErr          func() (err error)
	inspectFuncErr   func()
	afterErrCounter  uint64
	beforeErrCounter uint64
	ErrMock          mAsyncContextMockErr

	funcFiles          func() (f1 infrastructure.FileSystem)
	inspectFuncFiles   func()
	afterFilesCounter  uint64
	beforeFilesCounter uint64
	FilesMock          mAsyncContextMockFiles

	funcMessage          func() (s1 string)
	inspectFuncMessage   func()
	afterMessageCounter  uint64
	beforeMessageCounter uint64
	MessageMock          mAsyncContextMockMessage

	funcOutput          func() (w1 io.Writer)
	inspectFuncOutput   func()
	afterOutputCounter  uint64
	beforeOutputCounter uint64
	OutputMock          mAsyncContextMockOutput

	funcRepository          func() (r1 infrastructure.Repository)
	inspectFuncRepository   func()
	afterRepositoryCounter  uint64
	beforeRepositoryCounter uint64
	RepositoryMock          mAsyncContextMockRepository

	funcShell          func() (s1 infrastructure.Shell)
	inspectFuncShell   func()
	afterShellCounter  uint64
	beforeShellCounter uint64
	ShellMock          mAsyncContextMockShell

	funcStop          func()
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mAsyncContextMockStop

	funcValue          func(key interface{}) (p1 interface{})
	inspectFuncValue   func(key interface{})
	afterValueCounter  uint64
	beforeValueCounter uint64
	ValueMock          mAsyncContextMockValue
}

// NewAsyncContextMock returns a mock for internal.AsyncContext
func NewAsyncContextMock(t minimock.Tester) *AsyncContextMock {
	m := &AsyncContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArgsMock = mAsyncContextMockArgs{mock: m}

	m.DeadlineMock = mAsyncContextMockDeadline{mock: m}

	m.DoneMock = mAsyncContextMockDone{mock: m}

	m.ErrMock = mAsyncContextMockErr{mock: m}

	m.FilesMock = mAsyncContextMockFiles{mock: m}

	m.MessageMock = mAsyncContextMockMessage{mock: m}

	m.OutputMock = mAsyncContextMockOutput{mock: m}

	m.RepositoryMock = mAsyncContextMockRepository{mock: m}

	m.ShellMock = mAsyncContextMockShell{mock: m}

	m.StopMock = mAsyncContextMockStop{mock: m}

	m.ValueMock = mAsyncContextMockValue{mock: m}
	m.ValueMock.callArgs = []*AsyncContextMockValueParams{}

	return m
}

type mAsyncContextMockArgs struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockArgsExpectation
	expectations       []*AsyncContextMockArgsExpectation
}

// AsyncContextMockArgsExpectation specifies expectation struct of the AsyncContext.Args
type AsyncContextMockArgsExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockArgsResults
	Counter uint64
}

// AsyncContextMockArgsResults contains results of the AsyncContext.Args
type AsyncContextMockArgsResults struct {
	sa1 []string
}

// Expect sets up expected params for AsyncContext.Args
func (mmArgs *mAsyncContextMockArgs) Expect() *mAsyncContextMockArgs {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("AsyncContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &AsyncContextMockArgsExpectation{}
	}

	return mmArgs
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Args
func (mmArgs *mAsyncContextMockArgs) Inspect(f func()) *mAsyncContextMockArgs {
	if mmArgs.mock.inspectFuncArgs != nil {
		mmArgs.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Args")
	}

	mmArgs.mock.inspectFuncArgs = f

	return mmArgs
}

// Return sets up results that will be returned by AsyncContext.Args
func (mmArgs *mAsyncContextMockArgs) Return(sa1 []string) *AsyncContextMock {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("AsyncContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &AsyncContextMockArgsExpectation{mock: mmArgs.mock}
	}
	mmArgs.defaultExpectation.results = &AsyncContextMockArgsResults{sa1}
	return mmArgs.mock
}

//Set uses given function f to mock the AsyncContext.Args method
func (mmArgs *mAsyncContextMockArgs) Set(f func() (sa1 []string)) *AsyncContextMock {
	if mmArgs.defaultExpectation != nil {
		mmArgs.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Args method")
	}

	if len(mmArgs.expectations) > 0 {
		mmArgs.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Args method")
	}

	mmArgs.mock.funcArgs = f
	return mmArgs.mock
}

// Args implements internal.AsyncContext
func (mmArgs *AsyncContextMock) Args() (sa1 []string) {
	mm_atomic.AddUint64(&mmArgs.beforeArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmArgs.afterArgsCounter, 1)

	if mmArgs.inspectFuncArgs != nil {
		mmArgs.inspectFuncArgs()
	}

	if mmArgs.ArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArgs.ArgsMock.defaultExpectation.Counter, 1)

		mm_results := mmArgs.ArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmArgs.t.Fatal("No results are set for the AsyncContextMock.Args")
		}
		return (*mm_results).sa1
	}
	if mmArgs.funcArgs != nil {
		return mmArgs.funcArgs()
	}
	mmArgs.t.Fatalf("Unexpected call to AsyncContextMock.Args.")
	return
}

// ArgsAfterCounter returns a count of finished AsyncContextMock.Args invocations
func (mmArgs *AsyncContextMock) ArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.afterArgsCounter)
}

// ArgsBeforeCounter returns a count of AsyncContextMock.Args invocations
func (mmArgs *AsyncContextMock) ArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.beforeArgsCounter)
}

// MinimockArgsDone returns true if the count of the Args invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockArgsDone() bool {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	return true
}

// MinimockArgsInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockArgsInspect() {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Args")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Args")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Args")
	}
}

type mAsyncContextMockDeadline struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockDeadlineExpectation
	expectations       []*AsyncContextMockDeadlineExpectation
}

// AsyncContextMockDeadlineExpectation specifies expectation struct of the AsyncContext.Deadline
type AsyncContextMockDeadlineExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockDeadlineResults
	Counter uint64
}

// AsyncContextMockDeadlineResults contains results of the AsyncContext.Deadline
type AsyncContextMockDeadlineResults struct {
	deadline time.Time
	ok       bool
}

// Expect sets up expected params for AsyncContext.Deadline
func (mmDeadline *mAsyncContextMockDeadline) Expect() *mAsyncContextMockDeadline {
	if mmDeadline.mock.funcDeadline != nil {
		mmDeadline.mock.t.Fatalf("AsyncContextMock.Deadline mock is already set by Set")
	}

	if mmDeadline.defaultExpectation == nil {
		mmDeadline.defaultExpectation = &AsyncContextMockDeadlineExpectation{}
	}

	return mmDeadline
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Deadline
func (mmDeadline *mAsyncContextMockDeadline) Inspect(f func()) *mAsyncContextMockDeadline {
	if mmDeadline.mock.inspectFuncDeadline != nil {
		mmDeadline.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Deadline")
	}

	mmDeadline.mock.inspectFuncDeadline = f

	return mmDeadline
}

// Return sets up results that will be returned by AsyncContext.Deadline
func (mmDeadline *mAsyncContextMockDeadline) Return(deadline time.Time, ok bool) *AsyncContextMock {
	if mmDeadline.mock.funcDeadline != nil {
		mmDeadline.mock.t.Fatalf("AsyncContextMock.Deadline mock is already set by Set")
	}

	if mmDeadline.defaultExpectation == nil {
		mmDeadline.defaultExpectation = &AsyncContextMockDeadlineExpectation{mock: mmDeadline.mock}
	}
	mmDeadline.defaultExpectation.results = &AsyncContextMockDeadlineResults{deadline, ok}
	return mmDeadline.mock
}

//Set uses given function f to mock the AsyncContext.Deadline method
func (mmDeadline *mAsyncContextMockDeadline) Set(f func() (deadline time.Time, ok bool)) *AsyncContextMock {
	if mmDeadline.defaultExpectation != nil {
		mmDeadline.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Deadline method")
	}

	if len(mmDeadline.expectations) > 0 {
		mmDeadline.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Deadline method")
	}

	mmDeadline.mock.funcDeadline = f
	return mmDeadline.mock
}

// Deadline implements internal.AsyncContext
func (mmDeadline *AsyncContextMock) Deadline() (deadline time.Time, ok bool) {
	mm_atomic.AddUint64(&mmDeadline.beforeDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmDeadline.afterDeadlineCounter, 1)

	if mmDeadline.inspectFuncDeadline != nil {
		mmDeadline.inspectFuncDeadline()
	}

	if mmDeadline.DeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeadline.DeadlineMock.defaultExpectation.Counter, 1)

		mm_results := mmDeadline.DeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmDeadline.t.Fatal("No results are set for the AsyncContextMock.Deadline")
		}
		return (*mm_results).deadline, (*mm_results).ok
	}
	if mmDeadline.funcDeadline != nil {
		return mmDeadline.funcDeadline()
	}
	mmDeadline.t.Fatalf("Unexpected call to AsyncContextMock.Deadline.")
	return
}

// DeadlineAfterCounter returns a count of finished AsyncContextMock.Deadline invocations
func (mmDeadline *AsyncContextMock) DeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeadline.afterDeadlineCounter)
}

// DeadlineBeforeCounter returns a count of AsyncContextMock.Deadline invocations
func (mmDeadline *AsyncContextMock) DeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeadline.beforeDeadlineCounter)
}

// MinimockDeadlineDone returns true if the count of the Deadline invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockDeadlineDone() bool {
	for _, e := range m.DeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeadline != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeadlineInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockDeadlineInspect() {
	for _, e := range m.DeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Deadline")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Deadline")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeadline != nil && mm_atomic.LoadUint64(&m.afterDeadlineCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Deadline")
	}
}

type mAsyncContextMockDone struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockDoneExpectation
	expectations       []*AsyncContextMockDoneExpectation
}

// AsyncContextMockDoneExpectation specifies expectation struct of the AsyncContext.Done
type AsyncContextMockDoneExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockDoneResults
	Counter uint64
}

// AsyncContextMockDoneResults contains results of the AsyncContext.Done
type AsyncContextMockDoneResults struct {
	ch1 <-chan struct {
	}
}

// Expect sets up expected params for AsyncContext.Done
func (mmDone *mAsyncContextMockDone) Expect() *mAsyncContextMockDone {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("AsyncContextMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &AsyncContextMockDoneExpectation{}
	}

	return mmDone
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Done
func (mmDone *mAsyncContextMockDone) Inspect(f func()) *mAsyncContextMockDone {
	if mmDone.mock.inspectFuncDone != nil {
		mmDone.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Done")
	}

	mmDone.mock.inspectFuncDone = f

	return mmDone
}

// Return sets up results that will be returned by AsyncContext.Done
func (mmDone *mAsyncContextMockDone) Return(ch1 <-chan struct {
}) *AsyncContextMock {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("AsyncContextMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &AsyncContextMockDoneExpectation{mock: mmDone.mock}
	}
	mmDone.defaultExpectation.results = &AsyncContextMockDoneResults{ch1}
	return mmDone.mock
}

//Set uses given function f to mock the AsyncContext.Done method
func (mmDone *mAsyncContextMockDone) Set(f func() (ch1 <-chan struct {
})) *AsyncContextMock {
	if mmDone.defaultExpectation != nil {
		mmDone.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Done method")
	}

	if len(mmDone.expectations) > 0 {
		mmDone.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Done method")
	}

	mmDone.mock.funcDone = f
	return mmDone.mock
}

// Done implements internal.AsyncContext
func (mmDone *AsyncContextMock) Done() (ch1 <-chan struct {
}) {
	mm_atomic.AddUint64(&mmDone.beforeDoneCounter, 1)
	defer mm_atomic.AddUint64(&mmDone.afterDoneCounter, 1)

	if mmDone.inspectFuncDone != nil {
		mmDone.inspectFuncDone()
	}

	if mmDone.DoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDone.DoneMock.defaultExpectation.Counter, 1)

		mm_results := mmDone.DoneMock.defaultExpectation.results
		if mm_results == nil {
			mmDone.t.Fatal("No results are set for the AsyncContextMock.Done")
		}
		return (*mm_results).ch1
	}
	if mmDone.funcDone != nil {
		return mmDone.funcDone()
	}
	mmDone.t.Fatalf("Unexpected call to AsyncContextMock.Done.")
	return
}

// DoneAfterCounter returns a count of finished AsyncContextMock.Done invocations
func (mmDone *AsyncContextMock) DoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.afterDoneCounter)
}

// DoneBeforeCounter returns a count of AsyncContextMock.Done invocations
func (mmDone *AsyncContextMock) DoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.beforeDoneCounter)
}

// MinimockDoneDone returns true if the count of the Done invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockDoneDone() bool {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoneInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockDoneInspect() {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Done")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Done")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Done")
	}
}

type mAsyncContextMockErr struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockErrExpectation
	expectations       []*AsyncContextMockErrExpectation
}

// AsyncContextMockErrExpectation specifies expectation struct of the AsyncContext.Err
type AsyncContextMockErrExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockErrResults
	Counter uint64
}

// AsyncContextMockErrResults contains results of the AsyncContext.Err
type AsyncContextMockErrResults struct {
	err error
}

// Expect sets up expected params for AsyncContext.Err
func (mmErr *mAsyncContextMockErr) Expect() *mAsyncContextMockErr {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("AsyncContextMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &AsyncContextMockErrExpectation{}
	}

	return mmErr
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Err
func (mmErr *mAsyncContextMockErr) Inspect(f func()) *mAsyncContextMockErr {
	if mmErr.mock.inspectFuncErr != nil {
		mmErr.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Err")
	}

	mmErr.mock.inspectFuncErr = f

	return mmErr
}

// Return sets up results that will be returned by AsyncContext.Err
func (mmErr *mAsyncContextMockErr) Return(err error) *AsyncContextMock {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("AsyncContextMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &AsyncContextMockErrExpectation{mock: mmErr.mock}
	}
	mmErr.defaultExpectation.results = &AsyncContextMockErrResults{err}
	return mmErr.mock
}

//Set uses given function f to mock the AsyncContext.Err method
func (mmErr *mAsyncContextMockErr) Set(f func() (err error)) *AsyncContextMock {
	if mmErr.defaultExpectation != nil {
		mmErr.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Err method")
	}

	if len(mmErr.expectations) > 0 {
		mmErr.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Err method")
	}

	mmErr.mock.funcErr = f
	return mmErr.mock
}

// Err implements internal.AsyncContext
func (mmErr *AsyncContextMock) Err() (err error) {
	mm_atomic.AddUint64(&mmErr.beforeErrCounter, 1)
	defer mm_atomic.AddUint64(&mmErr.afterErrCounter, 1)

	if mmErr.inspectFuncErr != nil {
		mmErr.inspectFuncErr()
	}

	if mmErr.ErrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErr.ErrMock.defaultExpectation.Counter, 1)

		mm_results := mmErr.ErrMock.defaultExpectation.results
		if mm_results == nil {
			mmErr.t.Fatal("No results are set for the AsyncContextMock.Err")
		}
		return (*mm_results).err
	}
	if mmErr.funcErr != nil {
		return mmErr.funcErr()
	}
	mmErr.t.Fatalf("Unexpected call to AsyncContextMock.Err.")
	return
}

// ErrAfterCounter returns a count of finished AsyncContextMock.Err invocations
func (mmErr *AsyncContextMock) ErrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.afterErrCounter)
}

// ErrBeforeCounter returns a count of AsyncContextMock.Err invocations
func (mmErr *AsyncContextMock) ErrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.beforeErrCounter)
}

// MinimockErrDone returns true if the count of the Err invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockErrDone() bool {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockErrInspect() {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Err")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Err")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && mm_atomic.LoadUint64(&m.afterErrCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Err")
	}
}

type mAsyncContextMockFiles struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockFilesExpectation
	expectations       []*AsyncContextMockFilesExpectation
}

// AsyncContextMockFilesExpectation specifies expectation struct of the AsyncContext.Files
type AsyncContextMockFilesExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockFilesResults
	Counter uint64
}

// AsyncContextMockFilesResults contains results of the AsyncContext.Files
type AsyncContextMockFilesResults struct {
	f1 infrastructure.FileSystem
}

// Expect sets up expected params for AsyncContext.Files
func (mmFiles *mAsyncContextMockFiles) Expect() *mAsyncContextMockFiles {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("AsyncContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &AsyncContextMockFilesExpectation{}
	}

	return mmFiles
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Files
func (mmFiles *mAsyncContextMockFiles) Inspect(f func()) *mAsyncContextMockFiles {
	if mmFiles.mock.inspectFuncFiles != nil {
		mmFiles.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Files")
	}

	mmFiles.mock.inspectFuncFiles = f

	return mmFiles
}

// Return sets up results that will be returned by AsyncContext.Files
func (mmFiles *mAsyncContextMockFiles) Return(f1 infrastructure.FileSystem) *AsyncContextMock {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("AsyncContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &AsyncContextMockFilesExpectation{mock: mmFiles.mock}
	}
	mmFiles.defaultExpectation.results = &AsyncContextMockFilesResults{f1}
	return mmFiles.mock
}

//Set uses given function f to mock the AsyncContext.Files method
func (mmFiles *mAsyncContextMockFiles) Set(f func() (f1 infrastructure.FileSystem)) *AsyncContextMock {
	if mmFiles.defaultExpectation != nil {
		mmFiles.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Files method")
	}

	if len(mmFiles.expectations) > 0 {
		mmFiles.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Files method")
	}

	mmFiles.mock.funcFiles = f
	return mmFiles.mock
}

// Files implements internal.AsyncContext
func (mmFiles *AsyncContextMock) Files() (f1 infrastructure.FileSystem) {
	mm_atomic.AddUint64(&mmFiles.beforeFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmFiles.afterFilesCounter, 1)

	if mmFiles.inspectFuncFiles != nil {
		mmFiles.inspectFuncFiles()
	}

	if mmFiles.FilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFiles.FilesMock.defaultExpectation.Counter, 1)

		mm_results := mmFiles.FilesMock.defaultExpectation.results
		if mm_results == nil {
			mmFiles.t.Fatal("No results are set for the AsyncContextMock.Files")
		}
		return (*mm_results).f1
	}
	if mmFiles.funcFiles != nil {
		return mmFiles.funcFiles()
	}
	mmFiles.t.Fatalf("Unexpected call to AsyncContextMock.Files.")
	return
}

// FilesAfterCounter returns a count of finished AsyncContextMock.Files invocations
func (mmFiles *AsyncContextMock) FilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.afterFilesCounter)
}

// FilesBeforeCounter returns a count of AsyncContextMock.Files invocations
func (mmFiles *AsyncContextMock) FilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.beforeFilesCounter)
}

// MinimockFilesDone returns true if the count of the Files invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockFilesDone() bool {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	return true
}

// MinimockFilesInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockFilesInspect() {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Files")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Files")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Files")
	}
}

type mAsyncContextMockMessage struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockMessageExpectation
	expectations       []*AsyncContextMockMessageExpectation
}

// AsyncContextMockMessageExpectation specifies expectation struct of the AsyncContext.Message
type AsyncContextMockMessageExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockMessageResults
	Counter uint64
}

// AsyncContextMockMessageResults contains results of the AsyncContext.Message
type AsyncContextMockMessageResults struct {
	s1 string
}

// Expect sets up expected params for AsyncContext.Message
func (mmMessage *mAsyncContextMockMessage) Expect() *mAsyncContextMockMessage {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("AsyncContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &AsyncContextMockMessageExpectation{}
	}

	return mmMessage
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Message
func (mmMessage *mAsyncContextMockMessage) Inspect(f func()) *mAsyncContextMockMessage {
	if mmMessage.mock.inspectFuncMessage != nil {
		mmMessage.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Message")
	}

	mmMessage.mock.inspectFuncMessage = f

	return mmMessage
}

// Return sets up results that will be returned by AsyncContext.Message
func (mmMessage *mAsyncContextMockMessage) Return(s1 string) *AsyncContextMock {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("AsyncContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &AsyncContextMockMessageExpectation{mock: mmMessage.mock}
	}
	mmMessage.defaultExpectation.results = &AsyncContextMockMessageResults{s1}
	return mmMessage.mock
}

//Set uses given function f to mock the AsyncContext.Message method
func (mmMessage *mAsyncContextMockMessage) Set(f func() (s1 string)) *AsyncContextMock {
	if mmMessage.defaultExpectation != nil {
		mmMessage.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Message method")
	}

	if len(mmMessage.expectations) > 0 {
		mmMessage.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Message method")
	}

	mmMessage.mock.funcMessage = f
	return mmMessage.mock
}

// Message implements internal.AsyncContext
func (mmMessage *AsyncContextMock) Message() (s1 string) {
	mm_atomic.AddUint64(&mmMessage.beforeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmMessage.afterMessageCounter, 1)

	if mmMessage.inspectFuncMessage != nil {
		mmMessage.inspectFuncMessage()
	}

	if mmMessage.MessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMessage.MessageMock.defaultExpectation.Counter, 1)

		mm_results := mmMessage.MessageMock.defaultExpectation.results
		if mm_results == nil {
			mmMessage.t.Fatal("No results are set for the AsyncContextMock.Message")
		}
		return (*mm_results).s1
	}
	if mmMessage.funcMessage != nil {
		return mmMessage.funcMessage()
	}
	mmMessage.t.Fatalf("Unexpected call to AsyncContextMock.Message.")
	return
}

// MessageAfterCounter returns a count of finished AsyncContextMock.Message invocations
func (mmMessage *AsyncContextMock) MessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.afterMessageCounter)
}

// MessageBeforeCounter returns a count of AsyncContextMock.Message invocations
func (mmMessage *AsyncContextMock) MessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.beforeMessageCounter)
}

// MinimockMessageDone returns true if the count of the Message invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockMessageDone() bool {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockMessageInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockMessageInspect() {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Message")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Message")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Message")
	}
}

type mAsyncContextMockOutput struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockOutputExpectation
	expectations       []*AsyncContextMockOutputExpectation
}

// AsyncContextMockOutputExpectation specifies expectation struct of the AsyncContext.Output
type AsyncContextMockOutputExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockOutputResults
	Counter uint64
}

// AsyncContextMockOutputResults contains results of the AsyncContext.Output
type AsyncContextMockOutputResults struct {
	w1 io.Writer
}

// Expect sets up expected params for AsyncContext.Output
func (mmOutput *mAsyncContextMockOutput) Expect() *mAsyncContextMockOutput {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("AsyncContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &AsyncContextMockOutputExpectation{}
	}

	return mmOutput
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Output
func (mmOutput *mAsyncContextMockOutput) Inspect(f func()) *mAsyncContextMockOutput {
	if mmOutput.mock.inspectFuncOutput != nil {
		mmOutput.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Output")
	}

	mmOutput.mock.inspectFuncOutput = f

	return mmOutput
}

// Return sets up results that will be returned by AsyncContext.Output
func (mmOutput *mAsyncContextMockOutput) Return(w1 io.Writer) *AsyncContextMock {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("AsyncContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &AsyncContextMockOutputExpectation{mock: mmOutput.mock}
	}
	mmOutput.defaultExpectation.results = &AsyncContextMockOutputResults{w1}
	return mmOutput.mock
}

//Set uses given function f to mock the AsyncContext.Output method
func (mmOutput *mAsyncContextMockOutput) Set(f func() (w1 io.Writer)) *AsyncContextMock {
	if mmOutput.defaultExpectation != nil {
		mmOutput.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Output method")
	}

	if len(mmOutput.expectations) > 0 {
		mmOutput.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Output method")
	}

	mmOutput.mock.funcOutput = f
	return mmOutput.mock
}

// Output implements internal.AsyncContext
func (mmOutput *AsyncContextMock) Output() (w1 io.Writer) {
	mm_atomic.AddUint64(&mmOutput.beforeOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmOutput.afterOutputCounter, 1)

	if mmOutput.inspectFuncOutput != nil {
		mmOutput.inspectFuncOutput()
	}

	if mmOutput.OutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOutput.OutputMock.defaultExpectation.Counter, 1)

		mm_results := mmOutput.OutputMock.defaultExpectation.results
		if mm_results == nil {
			mmOutput.t.Fatal("No results are set for the AsyncContextMock.Output")
		}
		return (*mm_results).w1
	}
	if mmOutput.funcOutput != nil {
		return mmOutput.funcOutput()
	}
	mmOutput.t.Fatalf("Unexpected call to AsyncContextMock.Output.")
	return
}

// OutputAfterCounter returns a count of finished AsyncContextMock.Output invocations
func (mmOutput *AsyncContextMock) OutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.afterOutputCounter)
}

// OutputBeforeCounter returns a count of AsyncContextMock.Output invocations
func (mmOutput *AsyncContextMock) OutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.beforeOutputCounter)
}

// MinimockOutputDone returns true if the count of the Output invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockOutputDone() bool {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	return true
}

// MinimockOutputInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockOutputInspect() {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Output")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Output")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Output")
	}
}

type mAsyncContextMockRepository struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockRepositoryExpectation
	expectations       []*AsyncContextMockRepositoryExpectation
}

// AsyncContextMockRepositoryExpectation specifies expectation struct of the AsyncContext.Repository
type AsyncContextMockRepositoryExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockRepositoryResults
	Counter uint64
}

// AsyncContextMockRepositoryResults contains results of the AsyncContext.Repository
type AsyncContextMockRepositoryResults struct {
	r1 infrastructure.Repository
}

// Expect sets up expected params for AsyncContext.Repository
func (mmRepository *mAsyncContextMockRepository) Expect() *mAsyncContextMockRepository {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("AsyncContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &AsyncContextMockRepositoryExpectation{}
	}

	return mmRepository
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Repository
func (mmRepository *mAsyncContextMockRepository) Inspect(f func()) *mAsyncContextMockRepository {
	if mmRepository.mock.inspectFuncRepository != nil {
		mmRepository.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Repository")
	}

	mmRepository.mock.inspectFuncRepository = f

	return mmRepository
}

// Return sets up results that will be returned by AsyncContext.Repository
func (mmRepository *mAsyncContextMockRepository) Return(r1 infrastructure.Repository) *AsyncContextMock {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("AsyncContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &AsyncContextMockRepositoryExpectation{mock: mmRepository.mock}
	}
	mmRepository.defaultExpectation.results = &AsyncContextMockRepositoryResults{r1}
	return mmRepository.mock
}

//Set uses given function f to mock the AsyncContext.Repository method
func (mmRepository *mAsyncContextMockRepository) Set(f func() (r1 infrastructure.Repository)) *AsyncContextMock {
	if mmRepository.defaultExpectation != nil {
		mmRepository.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Repository method")
	}

	if len(mmRepository.expectations) > 0 {
		mmRepository.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Repository method")
	}

	mmRepository.mock.funcRepository = f
	return mmRepository.mock
}

// Repository implements internal.AsyncContext
func (mmRepository *AsyncContextMock) Repository() (r1 infrastructure.Repository) {
	mm_atomic.AddUint64(&mmRepository.beforeRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmRepository.afterRepositoryCounter, 1)

	if mmRepository.inspectFuncRepository != nil {
		mmRepository.inspectFuncRepository()
	}

	if mmRepository.RepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepository.RepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmRepository.RepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmRepository.t.Fatal("No results are set for the AsyncContextMock.Repository")
		}
		return (*mm_results).r1
	}
	if mmRepository.funcRepository != nil {
		return mmRepository.funcRepository()
	}
	mmRepository.t.Fatalf("Unexpected call to AsyncContextMock.Repository.")
	return
}

// RepositoryAfterCounter returns a count of finished AsyncContextMock.Repository invocations
func (mmRepository *AsyncContextMock) RepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.afterRepositoryCounter)
}

// RepositoryBeforeCounter returns a count of AsyncContextMock.Repository invocations
func (mmRepository *AsyncContextMock) RepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.beforeRepositoryCounter)
}

// MinimockRepositoryDone returns true if the count of the Repository invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockRepositoryDone() bool {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockRepositoryInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockRepositoryInspect() {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Repository")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Repository")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Repository")
	}
}

type mAsyncContextMockShell struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockShellExpectation
	expectations       []*AsyncContextMockShellExpectation
}

// AsyncContextMockShellExpectation specifies expectation struct of the AsyncContext.Shell
type AsyncContextMockShellExpectation struct {
	mock *AsyncContextMock

	results *AsyncContextMockShellResults
	Counter uint64
}

// AsyncContextMockShellResults contains results of the AsyncContext.Shell
type AsyncContextMockShellResults struct {
	s1 infrastructure.Shell
}

// Expect sets up expected params for AsyncContext.Shell
func (mmShell *mAsyncContextMockShell) Expect() *mAsyncContextMockShell {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("AsyncContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &AsyncContextMockShellExpectation{}
	}

	return mmShell
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Shell
func (mmShell *mAsyncContextMockShell) Inspect(f func()) *mAsyncContextMockShell {
	if mmShell.mock.inspectFuncShell != nil {
		mmShell.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Shell")
	}

	mmShell.mock.inspectFuncShell = f

	return mmShell
}

// Return sets up results that will be returned by AsyncContext.Shell
func (mmShell *mAsyncContextMockShell) Return(s1 infrastructure.Shell) *AsyncContextMock {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("AsyncContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &AsyncContextMockShellExpectation{mock: mmShell.mock}
	}
	mmShell.defaultExpectation.results = &AsyncContextMockShellResults{s1}
	return mmShell.mock
}

//Set uses given function f to mock the AsyncContext.Shell method
func (mmShell *mAsyncContextMockShell) Set(f func() (s1 infrastructure.Shell)) *AsyncContextMock {
	if mmShell.defaultExpectation != nil {
		mmShell.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Shell method")
	}

	if len(mmShell.expectations) > 0 {
		mmShell.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Shell method")
	}

	mmShell.mock.funcShell = f
	return mmShell.mock
}

// Shell implements internal.AsyncContext
func (mmShell *AsyncContextMock) Shell() (s1 infrastructure.Shell) {
	mm_atomic.AddUint64(&mmShell.beforeShellCounter, 1)
	defer mm_atomic.AddUint64(&mmShell.afterShellCounter, 1)

	if mmShell.inspectFuncShell != nil {
		mmShell.inspectFuncShell()
	}

	if mmShell.ShellMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShell.ShellMock.defaultExpectation.Counter, 1)

		mm_results := mmShell.ShellMock.defaultExpectation.results
		if mm_results == nil {
			mmShell.t.Fatal("No results are set for the AsyncContextMock.Shell")
		}
		return (*mm_results).s1
	}
	if mmShell.funcShell != nil {
		return mmShell.funcShell()
	}
	mmShell.t.Fatalf("Unexpected call to AsyncContextMock.Shell.")
	return
}

// ShellAfterCounter returns a count of finished AsyncContextMock.Shell invocations
func (mmShell *AsyncContextMock) ShellAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.afterShellCounter)
}

// ShellBeforeCounter returns a count of AsyncContextMock.Shell invocations
func (mmShell *AsyncContextMock) ShellBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.beforeShellCounter)
}

// MinimockShellDone returns true if the count of the Shell invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockShellDone() bool {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	return true
}

// MinimockShellInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockShellInspect() {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Shell")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Shell")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Shell")
	}
}

type mAsyncContextMockStop struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockStopExpectation
	expectations       []*AsyncContextMockStopExpectation
}

// AsyncContextMockStopExpectation specifies expectation struct of the AsyncContext.Stop
type AsyncContextMockStopExpectation struct {
	mock *AsyncContextMock

	Counter uint64
}

// Expect sets up expected params for AsyncContext.Stop
func (mmStop *mAsyncContextMockStop) Expect() *mAsyncContextMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("AsyncContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &AsyncContextMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Stop
func (mmStop *mAsyncContextMockStop) Inspect(f func()) *mAsyncContextMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by AsyncContext.Stop
func (mmStop *mAsyncContextMockStop) Return() *AsyncContextMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("AsyncContextMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &AsyncContextMockStopExpectation{mock: mmStop.mock}
	}

	return mmStop.mock
}

//Set uses given function f to mock the AsyncContext.Stop method
func (mmStop *mAsyncContextMockStop) Set(f func()) *AsyncContextMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// Stop implements internal.AsyncContext
func (mmStop *AsyncContextMock) Stop() {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		return

	}
	if mmStop.funcStop != nil {
		mmStop.funcStop()
		return
	}
	mmStop.t.Fatalf("Unexpected call to AsyncContextMock.Stop.")

}

// StopAfterCounter returns a count of finished AsyncContextMock.Stop invocations
func (mmStop *AsyncContextMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of AsyncContextMock.Stop invocations
func (mmStop *AsyncContextMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncContextMock.Stop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Stop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Stop")
	}
}

type mAsyncContextMockValue struct {
	mock               *AsyncContextMock
	defaultExpectation *AsyncContextMockValueExpectation
	expectations       []*AsyncContextMockValueExpectation

	callArgs []*AsyncContextMockValueParams
	mutex    sync.RWMutex
}

// AsyncContextMockValueExpectation specifies expectation struct of the AsyncContext.Value
type AsyncContextMockValueExpectation struct {
	mock    *AsyncContextMock
	params  *AsyncContextMockValueParams
	results *AsyncContextMockValueResults
	Counter uint64
}

// AsyncContextMockValueParams contains parameters of the AsyncContext.Value
type AsyncContextMockValueParams struct {
	key interface{}
}

// AsyncContextMockValueResults contains results of the AsyncContext.Value
type AsyncContextMockValueResults struct {
	p1 interface{}
}

// Expect sets up expected params for AsyncContext.Value
func (mmValue *mAsyncContextMockValue) Expect(key interface{}) *mAsyncContextMockValue {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("AsyncContextMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &AsyncContextMockValueExpectation{}
	}

	mmValue.defaultExpectation.params = &AsyncContextMockValueParams{key}
	for _, e := range mmValue.expectations {
		if minimock.Equal(e.params, mmValue.defaultExpectation.params) {
			mmValue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValue.defaultExpectation.params)
		}
	}

	return mmValue
}

// Inspect accepts an inspector function that has same arguments as the AsyncContext.Value
func (mmValue *mAsyncContextMockValue) Inspect(f func(key interface{})) *mAsyncContextMockValue {
	if mmValue.mock.inspectFuncValue != nil {
		mmValue.mock.t.Fatalf("Inspect function is already set for AsyncContextMock.Value")
	}

	mmValue.mock.inspectFuncValue = f

	return mmValue
}

// Return sets up results that will be returned by AsyncContext.Value
func (mmValue *mAsyncContextMockValue) Return(p1 interface{}) *AsyncContextMock {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("AsyncContextMock.Value mock is already set by Set")
	}

	if mmValue.defaultExpectation == nil {
		mmValue.defaultExpectation = &AsyncContextMockValueExpectation{mock: mmValue.mock}
	}
	mmValue.defaultExpectation.results = &AsyncContextMockValueResults{p1}
	return mmValue.mock
}

//Set uses given function f to mock the AsyncContext.Value method
func (mmValue *mAsyncContextMockValue) Set(f func(key interface{}) (p1 interface{})) *AsyncContextMock {
	if mmValue.defaultExpectation != nil {
		mmValue.mock.t.Fatalf("Default expectation is already set for the AsyncContext.Value method")
	}

	if len(mmValue.expectations) > 0 {
		mmValue.mock.t.Fatalf("Some expectations are already set for the AsyncContext.Value method")
	}

	mmValue.mock.funcValue = f
	return mmValue.mock
}

// When sets expectation for the AsyncContext.Value which will trigger the result defined by the following
// Then helper
func (mmValue *mAsyncContextMockValue) When(key interface{}) *AsyncContextMockValueExpectation {
	if mmValue.mock.funcValue != nil {
		mmValue.mock.t.Fatalf("AsyncContextMock.Value mock is already set by Set")
	}

	expectation := &AsyncContextMockValueExpectation{
		mock:   mmValue.mock,
		params: &AsyncContextMockValueParams{key},
	}
	mmValue.expectations = append(mmValue.expectations, expectation)
	return expectation
}

// Then sets up AsyncContext.Value return parameters for the expectation previously defined by the When method
func (e *AsyncContextMockValueExpectation) Then(p1 interface{}) *AsyncContextMock {
	e.results = &AsyncContextMockValueResults{p1}
	return e.mock
}

// Value implements internal.AsyncContext
func (mmValue *AsyncContextMock) Value(key interface{}) (p1 interface{}) {
	mm_atomic.AddUint64(&mmValue.beforeValueCounter, 1)
	defer mm_atomic.AddUint64(&mmValue.afterValueCounter, 1)

	if mmValue.inspectFuncValue != nil {
		mmValue.inspectFuncValue(key)
	}

	mm_params := &AsyncContextMockValueParams{key}

	// Record call args
	mmValue.ValueMock.mutex.Lock()
	mmValue.ValueMock.callArgs = append(mmValue.ValueMock.callArgs, mm_params)
	mmValue.ValueMock.mutex.Unlock()

	for _, e := range mmValue.ValueMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmValue.ValueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValue.ValueMock.defaultExpectation.Counter, 1)
		mm_want := mmValue.ValueMock.defaultExpectation.params
		mm_got := AsyncContextMockValueParams{key}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValue.t.Errorf("AsyncContextMock.Value got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValue.ValueMock.defaultExpectation.results
		if mm_results == nil {
			mmValue.t.Fatal("No results are set for the AsyncContextMock.Value")
		}
		return (*mm_results).p1
	}
	if mmValue.funcValue != nil {
		return mmValue.funcValue(key)
	}
	mmValue.t.Fatalf("Unexpected call to AsyncContextMock.Value. %v", key)
	return
}

// ValueAfterCounter returns a count of finished AsyncContextMock.Value invocations
func (mmValue *AsyncContextMock) ValueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.afterValueCounter)
}

// ValueBeforeCounter returns a count of AsyncContextMock.Value invocations
func (mmValue *AsyncContextMock) ValueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValue.beforeValueCounter)
}

// Calls returns a list of arguments used in each call to AsyncContextMock.Value.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValue *mAsyncContextMockValue) Calls() []*AsyncContextMockValueParams {
	mmValue.mutex.RLock()

	argCopy := make([]*AsyncContextMockValueParams, len(mmValue.callArgs))
	copy(argCopy, mmValue.callArgs)

	mmValue.mutex.RUnlock()

	return argCopy
}

// MinimockValueDone returns true if the count of the Value invocations corresponds
// the number of defined expectations
func (m *AsyncContextMock) MinimockValueDone() bool {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		return false
	}
	return true
}

// MinimockValueInspect logs each unmet expectation
func (m *AsyncContextMock) MinimockValueInspect() {
	for _, e := range m.ValueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AsyncContextMock.Value with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		if m.ValueMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AsyncContextMock.Value")
		} else {
			m.t.Errorf("Expected call to AsyncContextMock.Value with params: %#v", *m.ValueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValue != nil && mm_atomic.LoadUint64(&m.afterValueCounter) < 1 {
		m.t.Error("Expected call to AsyncContextMock.Value")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AsyncContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockArgsInspect()

		m.MinimockDeadlineInspect()

		m.MinimockDoneInspect()

		m.MinimockErrInspect()

		m.MinimockFilesInspect()

		m.MinimockMessageInspect()

		m.MinimockOutputInspect()

		m.MinimockRepositoryInspect()

		m.MinimockShellInspect()

		m.MinimockStopInspect()

		m.MinimockValueInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AsyncContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AsyncContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArgsDone() &&
		m.MinimockDeadlineDone() &&
		m.MinimockDoneDone() &&
		m.MinimockErrDone() &&
		m.MinimockFilesDone() &&
		m.MinimockMessageDone() &&
		m.MinimockOutputDone() &&
		m.MinimockRepositoryDone() &&
		m.MinimockShellDone() &&
		m.MinimockStopDone() &&
		m.MinimockValueDone()
}
