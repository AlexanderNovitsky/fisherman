package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/internal.SyncContext -o ./mocks\sync_context_mock.go

import (
	"fisherman/infrastructure"
	"io"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SyncContextMock implements internal.SyncContext
type SyncContextMock struct {
	t minimock.Tester

	funcArgs          func() (sa1 []string)
	inspectFuncArgs   func()
	afterArgsCounter  uint64
	beforeArgsCounter uint64
	ArgsMock          mSyncContextMockArgs

	funcFiles          func() (f1 infrastructure.FileSystem)
	inspectFuncFiles   func()
	afterFilesCounter  uint64
	beforeFilesCounter uint64
	FilesMock          mSyncContextMockFiles

	funcMessage          func() (s1 string)
	inspectFuncMessage   func()
	afterMessageCounter  uint64
	beforeMessageCounter uint64
	MessageMock          mSyncContextMockMessage

	funcOutput          func() (w1 io.Writer)
	inspectFuncOutput   func()
	afterOutputCounter  uint64
	beforeOutputCounter uint64
	OutputMock          mSyncContextMockOutput

	funcRepository          func() (r1 infrastructure.Repository)
	inspectFuncRepository   func()
	afterRepositoryCounter  uint64
	beforeRepositoryCounter uint64
	RepositoryMock          mSyncContextMockRepository

	funcShell          func() (s1 infrastructure.Shell)
	inspectFuncShell   func()
	afterShellCounter  uint64
	beforeShellCounter uint64
	ShellMock          mSyncContextMockShell
}

// NewSyncContextMock returns a mock for internal.SyncContext
func NewSyncContextMock(t minimock.Tester) *SyncContextMock {
	m := &SyncContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArgsMock = mSyncContextMockArgs{mock: m}

	m.FilesMock = mSyncContextMockFiles{mock: m}

	m.MessageMock = mSyncContextMockMessage{mock: m}

	m.OutputMock = mSyncContextMockOutput{mock: m}

	m.RepositoryMock = mSyncContextMockRepository{mock: m}

	m.ShellMock = mSyncContextMockShell{mock: m}

	return m
}

type mSyncContextMockArgs struct {
	mock               *SyncContextMock
	defaultExpectation *SyncContextMockArgsExpectation
	expectations       []*SyncContextMockArgsExpectation
}

// SyncContextMockArgsExpectation specifies expectation struct of the SyncContext.Args
type SyncContextMockArgsExpectation struct {
	mock *SyncContextMock

	results *SyncContextMockArgsResults
	Counter uint64
}

// SyncContextMockArgsResults contains results of the SyncContext.Args
type SyncContextMockArgsResults struct {
	sa1 []string
}

// Expect sets up expected params for SyncContext.Args
func (mmArgs *mSyncContextMockArgs) Expect() *mSyncContextMockArgs {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("SyncContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &SyncContextMockArgsExpectation{}
	}

	return mmArgs
}

// Inspect accepts an inspector function that has same arguments as the SyncContext.Args
func (mmArgs *mSyncContextMockArgs) Inspect(f func()) *mSyncContextMockArgs {
	if mmArgs.mock.inspectFuncArgs != nil {
		mmArgs.mock.t.Fatalf("Inspect function is already set for SyncContextMock.Args")
	}

	mmArgs.mock.inspectFuncArgs = f

	return mmArgs
}

// Return sets up results that will be returned by SyncContext.Args
func (mmArgs *mSyncContextMockArgs) Return(sa1 []string) *SyncContextMock {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("SyncContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &SyncContextMockArgsExpectation{mock: mmArgs.mock}
	}
	mmArgs.defaultExpectation.results = &SyncContextMockArgsResults{sa1}
	return mmArgs.mock
}

//Set uses given function f to mock the SyncContext.Args method
func (mmArgs *mSyncContextMockArgs) Set(f func() (sa1 []string)) *SyncContextMock {
	if mmArgs.defaultExpectation != nil {
		mmArgs.mock.t.Fatalf("Default expectation is already set for the SyncContext.Args method")
	}

	if len(mmArgs.expectations) > 0 {
		mmArgs.mock.t.Fatalf("Some expectations are already set for the SyncContext.Args method")
	}

	mmArgs.mock.funcArgs = f
	return mmArgs.mock
}

// Args implements internal.SyncContext
func (mmArgs *SyncContextMock) Args() (sa1 []string) {
	mm_atomic.AddUint64(&mmArgs.beforeArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmArgs.afterArgsCounter, 1)

	if mmArgs.inspectFuncArgs != nil {
		mmArgs.inspectFuncArgs()
	}

	if mmArgs.ArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArgs.ArgsMock.defaultExpectation.Counter, 1)

		mm_results := mmArgs.ArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmArgs.t.Fatal("No results are set for the SyncContextMock.Args")
		}
		return (*mm_results).sa1
	}
	if mmArgs.funcArgs != nil {
		return mmArgs.funcArgs()
	}
	mmArgs.t.Fatalf("Unexpected call to SyncContextMock.Args.")
	return
}

// ArgsAfterCounter returns a count of finished SyncContextMock.Args invocations
func (mmArgs *SyncContextMock) ArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.afterArgsCounter)
}

// ArgsBeforeCounter returns a count of SyncContextMock.Args invocations
func (mmArgs *SyncContextMock) ArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.beforeArgsCounter)
}

// MinimockArgsDone returns true if the count of the Args invocations corresponds
// the number of defined expectations
func (m *SyncContextMock) MinimockArgsDone() bool {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	return true
}

// MinimockArgsInspect logs each unmet expectation
func (m *SyncContextMock) MinimockArgsInspect() {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncContextMock.Args")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Args")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Args")
	}
}

type mSyncContextMockFiles struct {
	mock               *SyncContextMock
	defaultExpectation *SyncContextMockFilesExpectation
	expectations       []*SyncContextMockFilesExpectation
}

// SyncContextMockFilesExpectation specifies expectation struct of the SyncContext.Files
type SyncContextMockFilesExpectation struct {
	mock *SyncContextMock

	results *SyncContextMockFilesResults
	Counter uint64
}

// SyncContextMockFilesResults contains results of the SyncContext.Files
type SyncContextMockFilesResults struct {
	f1 infrastructure.FileSystem
}

// Expect sets up expected params for SyncContext.Files
func (mmFiles *mSyncContextMockFiles) Expect() *mSyncContextMockFiles {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("SyncContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &SyncContextMockFilesExpectation{}
	}

	return mmFiles
}

// Inspect accepts an inspector function that has same arguments as the SyncContext.Files
func (mmFiles *mSyncContextMockFiles) Inspect(f func()) *mSyncContextMockFiles {
	if mmFiles.mock.inspectFuncFiles != nil {
		mmFiles.mock.t.Fatalf("Inspect function is already set for SyncContextMock.Files")
	}

	mmFiles.mock.inspectFuncFiles = f

	return mmFiles
}

// Return sets up results that will be returned by SyncContext.Files
func (mmFiles *mSyncContextMockFiles) Return(f1 infrastructure.FileSystem) *SyncContextMock {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("SyncContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &SyncContextMockFilesExpectation{mock: mmFiles.mock}
	}
	mmFiles.defaultExpectation.results = &SyncContextMockFilesResults{f1}
	return mmFiles.mock
}

//Set uses given function f to mock the SyncContext.Files method
func (mmFiles *mSyncContextMockFiles) Set(f func() (f1 infrastructure.FileSystem)) *SyncContextMock {
	if mmFiles.defaultExpectation != nil {
		mmFiles.mock.t.Fatalf("Default expectation is already set for the SyncContext.Files method")
	}

	if len(mmFiles.expectations) > 0 {
		mmFiles.mock.t.Fatalf("Some expectations are already set for the SyncContext.Files method")
	}

	mmFiles.mock.funcFiles = f
	return mmFiles.mock
}

// Files implements internal.SyncContext
func (mmFiles *SyncContextMock) Files() (f1 infrastructure.FileSystem) {
	mm_atomic.AddUint64(&mmFiles.beforeFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmFiles.afterFilesCounter, 1)

	if mmFiles.inspectFuncFiles != nil {
		mmFiles.inspectFuncFiles()
	}

	if mmFiles.FilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFiles.FilesMock.defaultExpectation.Counter, 1)

		mm_results := mmFiles.FilesMock.defaultExpectation.results
		if mm_results == nil {
			mmFiles.t.Fatal("No results are set for the SyncContextMock.Files")
		}
		return (*mm_results).f1
	}
	if mmFiles.funcFiles != nil {
		return mmFiles.funcFiles()
	}
	mmFiles.t.Fatalf("Unexpected call to SyncContextMock.Files.")
	return
}

// FilesAfterCounter returns a count of finished SyncContextMock.Files invocations
func (mmFiles *SyncContextMock) FilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.afterFilesCounter)
}

// FilesBeforeCounter returns a count of SyncContextMock.Files invocations
func (mmFiles *SyncContextMock) FilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.beforeFilesCounter)
}

// MinimockFilesDone returns true if the count of the Files invocations corresponds
// the number of defined expectations
func (m *SyncContextMock) MinimockFilesDone() bool {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	return true
}

// MinimockFilesInspect logs each unmet expectation
func (m *SyncContextMock) MinimockFilesInspect() {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncContextMock.Files")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Files")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Files")
	}
}

type mSyncContextMockMessage struct {
	mock               *SyncContextMock
	defaultExpectation *SyncContextMockMessageExpectation
	expectations       []*SyncContextMockMessageExpectation
}

// SyncContextMockMessageExpectation specifies expectation struct of the SyncContext.Message
type SyncContextMockMessageExpectation struct {
	mock *SyncContextMock

	results *SyncContextMockMessageResults
	Counter uint64
}

// SyncContextMockMessageResults contains results of the SyncContext.Message
type SyncContextMockMessageResults struct {
	s1 string
}

// Expect sets up expected params for SyncContext.Message
func (mmMessage *mSyncContextMockMessage) Expect() *mSyncContextMockMessage {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("SyncContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &SyncContextMockMessageExpectation{}
	}

	return mmMessage
}

// Inspect accepts an inspector function that has same arguments as the SyncContext.Message
func (mmMessage *mSyncContextMockMessage) Inspect(f func()) *mSyncContextMockMessage {
	if mmMessage.mock.inspectFuncMessage != nil {
		mmMessage.mock.t.Fatalf("Inspect function is already set for SyncContextMock.Message")
	}

	mmMessage.mock.inspectFuncMessage = f

	return mmMessage
}

// Return sets up results that will be returned by SyncContext.Message
func (mmMessage *mSyncContextMockMessage) Return(s1 string) *SyncContextMock {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("SyncContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &SyncContextMockMessageExpectation{mock: mmMessage.mock}
	}
	mmMessage.defaultExpectation.results = &SyncContextMockMessageResults{s1}
	return mmMessage.mock
}

//Set uses given function f to mock the SyncContext.Message method
func (mmMessage *mSyncContextMockMessage) Set(f func() (s1 string)) *SyncContextMock {
	if mmMessage.defaultExpectation != nil {
		mmMessage.mock.t.Fatalf("Default expectation is already set for the SyncContext.Message method")
	}

	if len(mmMessage.expectations) > 0 {
		mmMessage.mock.t.Fatalf("Some expectations are already set for the SyncContext.Message method")
	}

	mmMessage.mock.funcMessage = f
	return mmMessage.mock
}

// Message implements internal.SyncContext
func (mmMessage *SyncContextMock) Message() (s1 string) {
	mm_atomic.AddUint64(&mmMessage.beforeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmMessage.afterMessageCounter, 1)

	if mmMessage.inspectFuncMessage != nil {
		mmMessage.inspectFuncMessage()
	}

	if mmMessage.MessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMessage.MessageMock.defaultExpectation.Counter, 1)

		mm_results := mmMessage.MessageMock.defaultExpectation.results
		if mm_results == nil {
			mmMessage.t.Fatal("No results are set for the SyncContextMock.Message")
		}
		return (*mm_results).s1
	}
	if mmMessage.funcMessage != nil {
		return mmMessage.funcMessage()
	}
	mmMessage.t.Fatalf("Unexpected call to SyncContextMock.Message.")
	return
}

// MessageAfterCounter returns a count of finished SyncContextMock.Message invocations
func (mmMessage *SyncContextMock) MessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.afterMessageCounter)
}

// MessageBeforeCounter returns a count of SyncContextMock.Message invocations
func (mmMessage *SyncContextMock) MessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.beforeMessageCounter)
}

// MinimockMessageDone returns true if the count of the Message invocations corresponds
// the number of defined expectations
func (m *SyncContextMock) MinimockMessageDone() bool {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockMessageInspect logs each unmet expectation
func (m *SyncContextMock) MinimockMessageInspect() {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncContextMock.Message")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Message")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Message")
	}
}

type mSyncContextMockOutput struct {
	mock               *SyncContextMock
	defaultExpectation *SyncContextMockOutputExpectation
	expectations       []*SyncContextMockOutputExpectation
}

// SyncContextMockOutputExpectation specifies expectation struct of the SyncContext.Output
type SyncContextMockOutputExpectation struct {
	mock *SyncContextMock

	results *SyncContextMockOutputResults
	Counter uint64
}

// SyncContextMockOutputResults contains results of the SyncContext.Output
type SyncContextMockOutputResults struct {
	w1 io.Writer
}

// Expect sets up expected params for SyncContext.Output
func (mmOutput *mSyncContextMockOutput) Expect() *mSyncContextMockOutput {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("SyncContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &SyncContextMockOutputExpectation{}
	}

	return mmOutput
}

// Inspect accepts an inspector function that has same arguments as the SyncContext.Output
func (mmOutput *mSyncContextMockOutput) Inspect(f func()) *mSyncContextMockOutput {
	if mmOutput.mock.inspectFuncOutput != nil {
		mmOutput.mock.t.Fatalf("Inspect function is already set for SyncContextMock.Output")
	}

	mmOutput.mock.inspectFuncOutput = f

	return mmOutput
}

// Return sets up results that will be returned by SyncContext.Output
func (mmOutput *mSyncContextMockOutput) Return(w1 io.Writer) *SyncContextMock {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("SyncContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &SyncContextMockOutputExpectation{mock: mmOutput.mock}
	}
	mmOutput.defaultExpectation.results = &SyncContextMockOutputResults{w1}
	return mmOutput.mock
}

//Set uses given function f to mock the SyncContext.Output method
func (mmOutput *mSyncContextMockOutput) Set(f func() (w1 io.Writer)) *SyncContextMock {
	if mmOutput.defaultExpectation != nil {
		mmOutput.mock.t.Fatalf("Default expectation is already set for the SyncContext.Output method")
	}

	if len(mmOutput.expectations) > 0 {
		mmOutput.mock.t.Fatalf("Some expectations are already set for the SyncContext.Output method")
	}

	mmOutput.mock.funcOutput = f
	return mmOutput.mock
}

// Output implements internal.SyncContext
func (mmOutput *SyncContextMock) Output() (w1 io.Writer) {
	mm_atomic.AddUint64(&mmOutput.beforeOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmOutput.afterOutputCounter, 1)

	if mmOutput.inspectFuncOutput != nil {
		mmOutput.inspectFuncOutput()
	}

	if mmOutput.OutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOutput.OutputMock.defaultExpectation.Counter, 1)

		mm_results := mmOutput.OutputMock.defaultExpectation.results
		if mm_results == nil {
			mmOutput.t.Fatal("No results are set for the SyncContextMock.Output")
		}
		return (*mm_results).w1
	}
	if mmOutput.funcOutput != nil {
		return mmOutput.funcOutput()
	}
	mmOutput.t.Fatalf("Unexpected call to SyncContextMock.Output.")
	return
}

// OutputAfterCounter returns a count of finished SyncContextMock.Output invocations
func (mmOutput *SyncContextMock) OutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.afterOutputCounter)
}

// OutputBeforeCounter returns a count of SyncContextMock.Output invocations
func (mmOutput *SyncContextMock) OutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.beforeOutputCounter)
}

// MinimockOutputDone returns true if the count of the Output invocations corresponds
// the number of defined expectations
func (m *SyncContextMock) MinimockOutputDone() bool {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	return true
}

// MinimockOutputInspect logs each unmet expectation
func (m *SyncContextMock) MinimockOutputInspect() {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncContextMock.Output")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Output")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Output")
	}
}

type mSyncContextMockRepository struct {
	mock               *SyncContextMock
	defaultExpectation *SyncContextMockRepositoryExpectation
	expectations       []*SyncContextMockRepositoryExpectation
}

// SyncContextMockRepositoryExpectation specifies expectation struct of the SyncContext.Repository
type SyncContextMockRepositoryExpectation struct {
	mock *SyncContextMock

	results *SyncContextMockRepositoryResults
	Counter uint64
}

// SyncContextMockRepositoryResults contains results of the SyncContext.Repository
type SyncContextMockRepositoryResults struct {
	r1 infrastructure.Repository
}

// Expect sets up expected params for SyncContext.Repository
func (mmRepository *mSyncContextMockRepository) Expect() *mSyncContextMockRepository {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("SyncContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &SyncContextMockRepositoryExpectation{}
	}

	return mmRepository
}

// Inspect accepts an inspector function that has same arguments as the SyncContext.Repository
func (mmRepository *mSyncContextMockRepository) Inspect(f func()) *mSyncContextMockRepository {
	if mmRepository.mock.inspectFuncRepository != nil {
		mmRepository.mock.t.Fatalf("Inspect function is already set for SyncContextMock.Repository")
	}

	mmRepository.mock.inspectFuncRepository = f

	return mmRepository
}

// Return sets up results that will be returned by SyncContext.Repository
func (mmRepository *mSyncContextMockRepository) Return(r1 infrastructure.Repository) *SyncContextMock {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("SyncContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &SyncContextMockRepositoryExpectation{mock: mmRepository.mock}
	}
	mmRepository.defaultExpectation.results = &SyncContextMockRepositoryResults{r1}
	return mmRepository.mock
}

//Set uses given function f to mock the SyncContext.Repository method
func (mmRepository *mSyncContextMockRepository) Set(f func() (r1 infrastructure.Repository)) *SyncContextMock {
	if mmRepository.defaultExpectation != nil {
		mmRepository.mock.t.Fatalf("Default expectation is already set for the SyncContext.Repository method")
	}

	if len(mmRepository.expectations) > 0 {
		mmRepository.mock.t.Fatalf("Some expectations are already set for the SyncContext.Repository method")
	}

	mmRepository.mock.funcRepository = f
	return mmRepository.mock
}

// Repository implements internal.SyncContext
func (mmRepository *SyncContextMock) Repository() (r1 infrastructure.Repository) {
	mm_atomic.AddUint64(&mmRepository.beforeRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmRepository.afterRepositoryCounter, 1)

	if mmRepository.inspectFuncRepository != nil {
		mmRepository.inspectFuncRepository()
	}

	if mmRepository.RepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepository.RepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmRepository.RepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmRepository.t.Fatal("No results are set for the SyncContextMock.Repository")
		}
		return (*mm_results).r1
	}
	if mmRepository.funcRepository != nil {
		return mmRepository.funcRepository()
	}
	mmRepository.t.Fatalf("Unexpected call to SyncContextMock.Repository.")
	return
}

// RepositoryAfterCounter returns a count of finished SyncContextMock.Repository invocations
func (mmRepository *SyncContextMock) RepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.afterRepositoryCounter)
}

// RepositoryBeforeCounter returns a count of SyncContextMock.Repository invocations
func (mmRepository *SyncContextMock) RepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.beforeRepositoryCounter)
}

// MinimockRepositoryDone returns true if the count of the Repository invocations corresponds
// the number of defined expectations
func (m *SyncContextMock) MinimockRepositoryDone() bool {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockRepositoryInspect logs each unmet expectation
func (m *SyncContextMock) MinimockRepositoryInspect() {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncContextMock.Repository")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Repository")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Repository")
	}
}

type mSyncContextMockShell struct {
	mock               *SyncContextMock
	defaultExpectation *SyncContextMockShellExpectation
	expectations       []*SyncContextMockShellExpectation
}

// SyncContextMockShellExpectation specifies expectation struct of the SyncContext.Shell
type SyncContextMockShellExpectation struct {
	mock *SyncContextMock

	results *SyncContextMockShellResults
	Counter uint64
}

// SyncContextMockShellResults contains results of the SyncContext.Shell
type SyncContextMockShellResults struct {
	s1 infrastructure.Shell
}

// Expect sets up expected params for SyncContext.Shell
func (mmShell *mSyncContextMockShell) Expect() *mSyncContextMockShell {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("SyncContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &SyncContextMockShellExpectation{}
	}

	return mmShell
}

// Inspect accepts an inspector function that has same arguments as the SyncContext.Shell
func (mmShell *mSyncContextMockShell) Inspect(f func()) *mSyncContextMockShell {
	if mmShell.mock.inspectFuncShell != nil {
		mmShell.mock.t.Fatalf("Inspect function is already set for SyncContextMock.Shell")
	}

	mmShell.mock.inspectFuncShell = f

	return mmShell
}

// Return sets up results that will be returned by SyncContext.Shell
func (mmShell *mSyncContextMockShell) Return(s1 infrastructure.Shell) *SyncContextMock {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("SyncContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &SyncContextMockShellExpectation{mock: mmShell.mock}
	}
	mmShell.defaultExpectation.results = &SyncContextMockShellResults{s1}
	return mmShell.mock
}

//Set uses given function f to mock the SyncContext.Shell method
func (mmShell *mSyncContextMockShell) Set(f func() (s1 infrastructure.Shell)) *SyncContextMock {
	if mmShell.defaultExpectation != nil {
		mmShell.mock.t.Fatalf("Default expectation is already set for the SyncContext.Shell method")
	}

	if len(mmShell.expectations) > 0 {
		mmShell.mock.t.Fatalf("Some expectations are already set for the SyncContext.Shell method")
	}

	mmShell.mock.funcShell = f
	return mmShell.mock
}

// Shell implements internal.SyncContext
func (mmShell *SyncContextMock) Shell() (s1 infrastructure.Shell) {
	mm_atomic.AddUint64(&mmShell.beforeShellCounter, 1)
	defer mm_atomic.AddUint64(&mmShell.afterShellCounter, 1)

	if mmShell.inspectFuncShell != nil {
		mmShell.inspectFuncShell()
	}

	if mmShell.ShellMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShell.ShellMock.defaultExpectation.Counter, 1)

		mm_results := mmShell.ShellMock.defaultExpectation.results
		if mm_results == nil {
			mmShell.t.Fatal("No results are set for the SyncContextMock.Shell")
		}
		return (*mm_results).s1
	}
	if mmShell.funcShell != nil {
		return mmShell.funcShell()
	}
	mmShell.t.Fatalf("Unexpected call to SyncContextMock.Shell.")
	return
}

// ShellAfterCounter returns a count of finished SyncContextMock.Shell invocations
func (mmShell *SyncContextMock) ShellAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.afterShellCounter)
}

// ShellBeforeCounter returns a count of SyncContextMock.Shell invocations
func (mmShell *SyncContextMock) ShellBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.beforeShellCounter)
}

// MinimockShellDone returns true if the count of the Shell invocations corresponds
// the number of defined expectations
func (m *SyncContextMock) MinimockShellDone() bool {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	return true
}

// MinimockShellInspect logs each unmet expectation
func (m *SyncContextMock) MinimockShellInspect() {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncContextMock.Shell")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Shell")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to SyncContextMock.Shell")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SyncContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockArgsInspect()

		m.MinimockFilesInspect()

		m.MinimockMessageInspect()

		m.MinimockOutputInspect()

		m.MinimockRepositoryInspect()

		m.MinimockShellInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SyncContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SyncContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArgsDone() &&
		m.MinimockFilesDone() &&
		m.MinimockMessageDone() &&
		m.MinimockOutputDone() &&
		m.MinimockRepositoryDone() &&
		m.MinimockShellDone()
}
