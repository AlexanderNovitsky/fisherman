package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/internal/validation.SyncValidationContext -o ./mocks\sync_validation_contextmock.go

import (
	"fisherman/infrastructure"
	"io"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SyncValidationContextMock implements validation.SyncValidationContext
type SyncValidationContextMock struct {
	t minimock.Tester

	funcArgs          func() (sa1 []string)
	inspectFuncArgs   func()
	afterArgsCounter  uint64
	beforeArgsCounter uint64
	ArgsMock          mSyncValidationContextMockArgs

	funcFiles          func() (f1 infrastructure.FileSystem)
	inspectFuncFiles   func()
	afterFilesCounter  uint64
	beforeFilesCounter uint64
	FilesMock          mSyncValidationContextMockFiles

	funcMessage          func() (s1 string)
	inspectFuncMessage   func()
	afterMessageCounter  uint64
	beforeMessageCounter uint64
	MessageMock          mSyncValidationContextMockMessage

	funcOutput          func() (w1 io.Writer)
	inspectFuncOutput   func()
	afterOutputCounter  uint64
	beforeOutputCounter uint64
	OutputMock          mSyncValidationContextMockOutput

	funcRepository          func() (r1 infrastructure.Repository)
	inspectFuncRepository   func()
	afterRepositoryCounter  uint64
	beforeRepositoryCounter uint64
	RepositoryMock          mSyncValidationContextMockRepository

	funcShell          func() (s1 infrastructure.Shell)
	inspectFuncShell   func()
	afterShellCounter  uint64
	beforeShellCounter uint64
	ShellMock          mSyncValidationContextMockShell
}

// NewSyncValidationContextMock returns a mock for validation.SyncValidationContext
func NewSyncValidationContextMock(t minimock.Tester) *SyncValidationContextMock {
	m := &SyncValidationContextMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArgsMock = mSyncValidationContextMockArgs{mock: m}

	m.FilesMock = mSyncValidationContextMockFiles{mock: m}

	m.MessageMock = mSyncValidationContextMockMessage{mock: m}

	m.OutputMock = mSyncValidationContextMockOutput{mock: m}

	m.RepositoryMock = mSyncValidationContextMockRepository{mock: m}

	m.ShellMock = mSyncValidationContextMockShell{mock: m}

	return m
}

type mSyncValidationContextMockArgs struct {
	mock               *SyncValidationContextMock
	defaultExpectation *SyncValidationContextMockArgsExpectation
	expectations       []*SyncValidationContextMockArgsExpectation
}

// SyncValidationContextMockArgsExpectation specifies expectation struct of the SyncValidationContext.Args
type SyncValidationContextMockArgsExpectation struct {
	mock *SyncValidationContextMock

	results *SyncValidationContextMockArgsResults
	Counter uint64
}

// SyncValidationContextMockArgsResults contains results of the SyncValidationContext.Args
type SyncValidationContextMockArgsResults struct {
	sa1 []string
}

// Expect sets up expected params for SyncValidationContext.Args
func (mmArgs *mSyncValidationContextMockArgs) Expect() *mSyncValidationContextMockArgs {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("SyncValidationContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &SyncValidationContextMockArgsExpectation{}
	}

	return mmArgs
}

// Inspect accepts an inspector function that has same arguments as the SyncValidationContext.Args
func (mmArgs *mSyncValidationContextMockArgs) Inspect(f func()) *mSyncValidationContextMockArgs {
	if mmArgs.mock.inspectFuncArgs != nil {
		mmArgs.mock.t.Fatalf("Inspect function is already set for SyncValidationContextMock.Args")
	}

	mmArgs.mock.inspectFuncArgs = f

	return mmArgs
}

// Return sets up results that will be returned by SyncValidationContext.Args
func (mmArgs *mSyncValidationContextMockArgs) Return(sa1 []string) *SyncValidationContextMock {
	if mmArgs.mock.funcArgs != nil {
		mmArgs.mock.t.Fatalf("SyncValidationContextMock.Args mock is already set by Set")
	}

	if mmArgs.defaultExpectation == nil {
		mmArgs.defaultExpectation = &SyncValidationContextMockArgsExpectation{mock: mmArgs.mock}
	}
	mmArgs.defaultExpectation.results = &SyncValidationContextMockArgsResults{sa1}
	return mmArgs.mock
}

//Set uses given function f to mock the SyncValidationContext.Args method
func (mmArgs *mSyncValidationContextMockArgs) Set(f func() (sa1 []string)) *SyncValidationContextMock {
	if mmArgs.defaultExpectation != nil {
		mmArgs.mock.t.Fatalf("Default expectation is already set for the SyncValidationContext.Args method")
	}

	if len(mmArgs.expectations) > 0 {
		mmArgs.mock.t.Fatalf("Some expectations are already set for the SyncValidationContext.Args method")
	}

	mmArgs.mock.funcArgs = f
	return mmArgs.mock
}

// Args implements validation.SyncValidationContext
func (mmArgs *SyncValidationContextMock) Args() (sa1 []string) {
	mm_atomic.AddUint64(&mmArgs.beforeArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmArgs.afterArgsCounter, 1)

	if mmArgs.inspectFuncArgs != nil {
		mmArgs.inspectFuncArgs()
	}

	if mmArgs.ArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArgs.ArgsMock.defaultExpectation.Counter, 1)

		mm_results := mmArgs.ArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmArgs.t.Fatal("No results are set for the SyncValidationContextMock.Args")
		}
		return (*mm_results).sa1
	}
	if mmArgs.funcArgs != nil {
		return mmArgs.funcArgs()
	}
	mmArgs.t.Fatalf("Unexpected call to SyncValidationContextMock.Args.")
	return
}

// ArgsAfterCounter returns a count of finished SyncValidationContextMock.Args invocations
func (mmArgs *SyncValidationContextMock) ArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.afterArgsCounter)
}

// ArgsBeforeCounter returns a count of SyncValidationContextMock.Args invocations
func (mmArgs *SyncValidationContextMock) ArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArgs.beforeArgsCounter)
}

// MinimockArgsDone returns true if the count of the Args invocations corresponds
// the number of defined expectations
func (m *SyncValidationContextMock) MinimockArgsDone() bool {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		return false
	}
	return true
}

// MinimockArgsInspect logs each unmet expectation
func (m *SyncValidationContextMock) MinimockArgsInspect() {
	for _, e := range m.ArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncValidationContextMock.Args")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Args")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArgs != nil && mm_atomic.LoadUint64(&m.afterArgsCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Args")
	}
}

type mSyncValidationContextMockFiles struct {
	mock               *SyncValidationContextMock
	defaultExpectation *SyncValidationContextMockFilesExpectation
	expectations       []*SyncValidationContextMockFilesExpectation
}

// SyncValidationContextMockFilesExpectation specifies expectation struct of the SyncValidationContext.Files
type SyncValidationContextMockFilesExpectation struct {
	mock *SyncValidationContextMock

	results *SyncValidationContextMockFilesResults
	Counter uint64
}

// SyncValidationContextMockFilesResults contains results of the SyncValidationContext.Files
type SyncValidationContextMockFilesResults struct {
	f1 infrastructure.FileSystem
}

// Expect sets up expected params for SyncValidationContext.Files
func (mmFiles *mSyncValidationContextMockFiles) Expect() *mSyncValidationContextMockFiles {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("SyncValidationContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &SyncValidationContextMockFilesExpectation{}
	}

	return mmFiles
}

// Inspect accepts an inspector function that has same arguments as the SyncValidationContext.Files
func (mmFiles *mSyncValidationContextMockFiles) Inspect(f func()) *mSyncValidationContextMockFiles {
	if mmFiles.mock.inspectFuncFiles != nil {
		mmFiles.mock.t.Fatalf("Inspect function is already set for SyncValidationContextMock.Files")
	}

	mmFiles.mock.inspectFuncFiles = f

	return mmFiles
}

// Return sets up results that will be returned by SyncValidationContext.Files
func (mmFiles *mSyncValidationContextMockFiles) Return(f1 infrastructure.FileSystem) *SyncValidationContextMock {
	if mmFiles.mock.funcFiles != nil {
		mmFiles.mock.t.Fatalf("SyncValidationContextMock.Files mock is already set by Set")
	}

	if mmFiles.defaultExpectation == nil {
		mmFiles.defaultExpectation = &SyncValidationContextMockFilesExpectation{mock: mmFiles.mock}
	}
	mmFiles.defaultExpectation.results = &SyncValidationContextMockFilesResults{f1}
	return mmFiles.mock
}

//Set uses given function f to mock the SyncValidationContext.Files method
func (mmFiles *mSyncValidationContextMockFiles) Set(f func() (f1 infrastructure.FileSystem)) *SyncValidationContextMock {
	if mmFiles.defaultExpectation != nil {
		mmFiles.mock.t.Fatalf("Default expectation is already set for the SyncValidationContext.Files method")
	}

	if len(mmFiles.expectations) > 0 {
		mmFiles.mock.t.Fatalf("Some expectations are already set for the SyncValidationContext.Files method")
	}

	mmFiles.mock.funcFiles = f
	return mmFiles.mock
}

// Files implements validation.SyncValidationContext
func (mmFiles *SyncValidationContextMock) Files() (f1 infrastructure.FileSystem) {
	mm_atomic.AddUint64(&mmFiles.beforeFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmFiles.afterFilesCounter, 1)

	if mmFiles.inspectFuncFiles != nil {
		mmFiles.inspectFuncFiles()
	}

	if mmFiles.FilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFiles.FilesMock.defaultExpectation.Counter, 1)

		mm_results := mmFiles.FilesMock.defaultExpectation.results
		if mm_results == nil {
			mmFiles.t.Fatal("No results are set for the SyncValidationContextMock.Files")
		}
		return (*mm_results).f1
	}
	if mmFiles.funcFiles != nil {
		return mmFiles.funcFiles()
	}
	mmFiles.t.Fatalf("Unexpected call to SyncValidationContextMock.Files.")
	return
}

// FilesAfterCounter returns a count of finished SyncValidationContextMock.Files invocations
func (mmFiles *SyncValidationContextMock) FilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.afterFilesCounter)
}

// FilesBeforeCounter returns a count of SyncValidationContextMock.Files invocations
func (mmFiles *SyncValidationContextMock) FilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFiles.beforeFilesCounter)
}

// MinimockFilesDone returns true if the count of the Files invocations corresponds
// the number of defined expectations
func (m *SyncValidationContextMock) MinimockFilesDone() bool {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		return false
	}
	return true
}

// MinimockFilesInspect logs each unmet expectation
func (m *SyncValidationContextMock) MinimockFilesInspect() {
	for _, e := range m.FilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncValidationContextMock.Files")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Files")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFiles != nil && mm_atomic.LoadUint64(&m.afterFilesCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Files")
	}
}

type mSyncValidationContextMockMessage struct {
	mock               *SyncValidationContextMock
	defaultExpectation *SyncValidationContextMockMessageExpectation
	expectations       []*SyncValidationContextMockMessageExpectation
}

// SyncValidationContextMockMessageExpectation specifies expectation struct of the SyncValidationContext.Message
type SyncValidationContextMockMessageExpectation struct {
	mock *SyncValidationContextMock

	results *SyncValidationContextMockMessageResults
	Counter uint64
}

// SyncValidationContextMockMessageResults contains results of the SyncValidationContext.Message
type SyncValidationContextMockMessageResults struct {
	s1 string
}

// Expect sets up expected params for SyncValidationContext.Message
func (mmMessage *mSyncValidationContextMockMessage) Expect() *mSyncValidationContextMockMessage {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("SyncValidationContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &SyncValidationContextMockMessageExpectation{}
	}

	return mmMessage
}

// Inspect accepts an inspector function that has same arguments as the SyncValidationContext.Message
func (mmMessage *mSyncValidationContextMockMessage) Inspect(f func()) *mSyncValidationContextMockMessage {
	if mmMessage.mock.inspectFuncMessage != nil {
		mmMessage.mock.t.Fatalf("Inspect function is already set for SyncValidationContextMock.Message")
	}

	mmMessage.mock.inspectFuncMessage = f

	return mmMessage
}

// Return sets up results that will be returned by SyncValidationContext.Message
func (mmMessage *mSyncValidationContextMockMessage) Return(s1 string) *SyncValidationContextMock {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("SyncValidationContextMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &SyncValidationContextMockMessageExpectation{mock: mmMessage.mock}
	}
	mmMessage.defaultExpectation.results = &SyncValidationContextMockMessageResults{s1}
	return mmMessage.mock
}

//Set uses given function f to mock the SyncValidationContext.Message method
func (mmMessage *mSyncValidationContextMockMessage) Set(f func() (s1 string)) *SyncValidationContextMock {
	if mmMessage.defaultExpectation != nil {
		mmMessage.mock.t.Fatalf("Default expectation is already set for the SyncValidationContext.Message method")
	}

	if len(mmMessage.expectations) > 0 {
		mmMessage.mock.t.Fatalf("Some expectations are already set for the SyncValidationContext.Message method")
	}

	mmMessage.mock.funcMessage = f
	return mmMessage.mock
}

// Message implements validation.SyncValidationContext
func (mmMessage *SyncValidationContextMock) Message() (s1 string) {
	mm_atomic.AddUint64(&mmMessage.beforeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmMessage.afterMessageCounter, 1)

	if mmMessage.inspectFuncMessage != nil {
		mmMessage.inspectFuncMessage()
	}

	if mmMessage.MessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMessage.MessageMock.defaultExpectation.Counter, 1)

		mm_results := mmMessage.MessageMock.defaultExpectation.results
		if mm_results == nil {
			mmMessage.t.Fatal("No results are set for the SyncValidationContextMock.Message")
		}
		return (*mm_results).s1
	}
	if mmMessage.funcMessage != nil {
		return mmMessage.funcMessage()
	}
	mmMessage.t.Fatalf("Unexpected call to SyncValidationContextMock.Message.")
	return
}

// MessageAfterCounter returns a count of finished SyncValidationContextMock.Message invocations
func (mmMessage *SyncValidationContextMock) MessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.afterMessageCounter)
}

// MessageBeforeCounter returns a count of SyncValidationContextMock.Message invocations
func (mmMessage *SyncValidationContextMock) MessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.beforeMessageCounter)
}

// MinimockMessageDone returns true if the count of the Message invocations corresponds
// the number of defined expectations
func (m *SyncValidationContextMock) MinimockMessageDone() bool {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockMessageInspect logs each unmet expectation
func (m *SyncValidationContextMock) MinimockMessageInspect() {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncValidationContextMock.Message")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Message")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Message")
	}
}

type mSyncValidationContextMockOutput struct {
	mock               *SyncValidationContextMock
	defaultExpectation *SyncValidationContextMockOutputExpectation
	expectations       []*SyncValidationContextMockOutputExpectation
}

// SyncValidationContextMockOutputExpectation specifies expectation struct of the SyncValidationContext.Output
type SyncValidationContextMockOutputExpectation struct {
	mock *SyncValidationContextMock

	results *SyncValidationContextMockOutputResults
	Counter uint64
}

// SyncValidationContextMockOutputResults contains results of the SyncValidationContext.Output
type SyncValidationContextMockOutputResults struct {
	w1 io.Writer
}

// Expect sets up expected params for SyncValidationContext.Output
func (mmOutput *mSyncValidationContextMockOutput) Expect() *mSyncValidationContextMockOutput {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("SyncValidationContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &SyncValidationContextMockOutputExpectation{}
	}

	return mmOutput
}

// Inspect accepts an inspector function that has same arguments as the SyncValidationContext.Output
func (mmOutput *mSyncValidationContextMockOutput) Inspect(f func()) *mSyncValidationContextMockOutput {
	if mmOutput.mock.inspectFuncOutput != nil {
		mmOutput.mock.t.Fatalf("Inspect function is already set for SyncValidationContextMock.Output")
	}

	mmOutput.mock.inspectFuncOutput = f

	return mmOutput
}

// Return sets up results that will be returned by SyncValidationContext.Output
func (mmOutput *mSyncValidationContextMockOutput) Return(w1 io.Writer) *SyncValidationContextMock {
	if mmOutput.mock.funcOutput != nil {
		mmOutput.mock.t.Fatalf("SyncValidationContextMock.Output mock is already set by Set")
	}

	if mmOutput.defaultExpectation == nil {
		mmOutput.defaultExpectation = &SyncValidationContextMockOutputExpectation{mock: mmOutput.mock}
	}
	mmOutput.defaultExpectation.results = &SyncValidationContextMockOutputResults{w1}
	return mmOutput.mock
}

//Set uses given function f to mock the SyncValidationContext.Output method
func (mmOutput *mSyncValidationContextMockOutput) Set(f func() (w1 io.Writer)) *SyncValidationContextMock {
	if mmOutput.defaultExpectation != nil {
		mmOutput.mock.t.Fatalf("Default expectation is already set for the SyncValidationContext.Output method")
	}

	if len(mmOutput.expectations) > 0 {
		mmOutput.mock.t.Fatalf("Some expectations are already set for the SyncValidationContext.Output method")
	}

	mmOutput.mock.funcOutput = f
	return mmOutput.mock
}

// Output implements validation.SyncValidationContext
func (mmOutput *SyncValidationContextMock) Output() (w1 io.Writer) {
	mm_atomic.AddUint64(&mmOutput.beforeOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmOutput.afterOutputCounter, 1)

	if mmOutput.inspectFuncOutput != nil {
		mmOutput.inspectFuncOutput()
	}

	if mmOutput.OutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOutput.OutputMock.defaultExpectation.Counter, 1)

		mm_results := mmOutput.OutputMock.defaultExpectation.results
		if mm_results == nil {
			mmOutput.t.Fatal("No results are set for the SyncValidationContextMock.Output")
		}
		return (*mm_results).w1
	}
	if mmOutput.funcOutput != nil {
		return mmOutput.funcOutput()
	}
	mmOutput.t.Fatalf("Unexpected call to SyncValidationContextMock.Output.")
	return
}

// OutputAfterCounter returns a count of finished SyncValidationContextMock.Output invocations
func (mmOutput *SyncValidationContextMock) OutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.afterOutputCounter)
}

// OutputBeforeCounter returns a count of SyncValidationContextMock.Output invocations
func (mmOutput *SyncValidationContextMock) OutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOutput.beforeOutputCounter)
}

// MinimockOutputDone returns true if the count of the Output invocations corresponds
// the number of defined expectations
func (m *SyncValidationContextMock) MinimockOutputDone() bool {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		return false
	}
	return true
}

// MinimockOutputInspect logs each unmet expectation
func (m *SyncValidationContextMock) MinimockOutputInspect() {
	for _, e := range m.OutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncValidationContextMock.Output")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Output")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOutput != nil && mm_atomic.LoadUint64(&m.afterOutputCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Output")
	}
}

type mSyncValidationContextMockRepository struct {
	mock               *SyncValidationContextMock
	defaultExpectation *SyncValidationContextMockRepositoryExpectation
	expectations       []*SyncValidationContextMockRepositoryExpectation
}

// SyncValidationContextMockRepositoryExpectation specifies expectation struct of the SyncValidationContext.Repository
type SyncValidationContextMockRepositoryExpectation struct {
	mock *SyncValidationContextMock

	results *SyncValidationContextMockRepositoryResults
	Counter uint64
}

// SyncValidationContextMockRepositoryResults contains results of the SyncValidationContext.Repository
type SyncValidationContextMockRepositoryResults struct {
	r1 infrastructure.Repository
}

// Expect sets up expected params for SyncValidationContext.Repository
func (mmRepository *mSyncValidationContextMockRepository) Expect() *mSyncValidationContextMockRepository {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("SyncValidationContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &SyncValidationContextMockRepositoryExpectation{}
	}

	return mmRepository
}

// Inspect accepts an inspector function that has same arguments as the SyncValidationContext.Repository
func (mmRepository *mSyncValidationContextMockRepository) Inspect(f func()) *mSyncValidationContextMockRepository {
	if mmRepository.mock.inspectFuncRepository != nil {
		mmRepository.mock.t.Fatalf("Inspect function is already set for SyncValidationContextMock.Repository")
	}

	mmRepository.mock.inspectFuncRepository = f

	return mmRepository
}

// Return sets up results that will be returned by SyncValidationContext.Repository
func (mmRepository *mSyncValidationContextMockRepository) Return(r1 infrastructure.Repository) *SyncValidationContextMock {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("SyncValidationContextMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &SyncValidationContextMockRepositoryExpectation{mock: mmRepository.mock}
	}
	mmRepository.defaultExpectation.results = &SyncValidationContextMockRepositoryResults{r1}
	return mmRepository.mock
}

//Set uses given function f to mock the SyncValidationContext.Repository method
func (mmRepository *mSyncValidationContextMockRepository) Set(f func() (r1 infrastructure.Repository)) *SyncValidationContextMock {
	if mmRepository.defaultExpectation != nil {
		mmRepository.mock.t.Fatalf("Default expectation is already set for the SyncValidationContext.Repository method")
	}

	if len(mmRepository.expectations) > 0 {
		mmRepository.mock.t.Fatalf("Some expectations are already set for the SyncValidationContext.Repository method")
	}

	mmRepository.mock.funcRepository = f
	return mmRepository.mock
}

// Repository implements validation.SyncValidationContext
func (mmRepository *SyncValidationContextMock) Repository() (r1 infrastructure.Repository) {
	mm_atomic.AddUint64(&mmRepository.beforeRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmRepository.afterRepositoryCounter, 1)

	if mmRepository.inspectFuncRepository != nil {
		mmRepository.inspectFuncRepository()
	}

	if mmRepository.RepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepository.RepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmRepository.RepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmRepository.t.Fatal("No results are set for the SyncValidationContextMock.Repository")
		}
		return (*mm_results).r1
	}
	if mmRepository.funcRepository != nil {
		return mmRepository.funcRepository()
	}
	mmRepository.t.Fatalf("Unexpected call to SyncValidationContextMock.Repository.")
	return
}

// RepositoryAfterCounter returns a count of finished SyncValidationContextMock.Repository invocations
func (mmRepository *SyncValidationContextMock) RepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.afterRepositoryCounter)
}

// RepositoryBeforeCounter returns a count of SyncValidationContextMock.Repository invocations
func (mmRepository *SyncValidationContextMock) RepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.beforeRepositoryCounter)
}

// MinimockRepositoryDone returns true if the count of the Repository invocations corresponds
// the number of defined expectations
func (m *SyncValidationContextMock) MinimockRepositoryDone() bool {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockRepositoryInspect logs each unmet expectation
func (m *SyncValidationContextMock) MinimockRepositoryInspect() {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncValidationContextMock.Repository")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Repository")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && mm_atomic.LoadUint64(&m.afterRepositoryCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Repository")
	}
}

type mSyncValidationContextMockShell struct {
	mock               *SyncValidationContextMock
	defaultExpectation *SyncValidationContextMockShellExpectation
	expectations       []*SyncValidationContextMockShellExpectation
}

// SyncValidationContextMockShellExpectation specifies expectation struct of the SyncValidationContext.Shell
type SyncValidationContextMockShellExpectation struct {
	mock *SyncValidationContextMock

	results *SyncValidationContextMockShellResults
	Counter uint64
}

// SyncValidationContextMockShellResults contains results of the SyncValidationContext.Shell
type SyncValidationContextMockShellResults struct {
	s1 infrastructure.Shell
}

// Expect sets up expected params for SyncValidationContext.Shell
func (mmShell *mSyncValidationContextMockShell) Expect() *mSyncValidationContextMockShell {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("SyncValidationContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &SyncValidationContextMockShellExpectation{}
	}

	return mmShell
}

// Inspect accepts an inspector function that has same arguments as the SyncValidationContext.Shell
func (mmShell *mSyncValidationContextMockShell) Inspect(f func()) *mSyncValidationContextMockShell {
	if mmShell.mock.inspectFuncShell != nil {
		mmShell.mock.t.Fatalf("Inspect function is already set for SyncValidationContextMock.Shell")
	}

	mmShell.mock.inspectFuncShell = f

	return mmShell
}

// Return sets up results that will be returned by SyncValidationContext.Shell
func (mmShell *mSyncValidationContextMockShell) Return(s1 infrastructure.Shell) *SyncValidationContextMock {
	if mmShell.mock.funcShell != nil {
		mmShell.mock.t.Fatalf("SyncValidationContextMock.Shell mock is already set by Set")
	}

	if mmShell.defaultExpectation == nil {
		mmShell.defaultExpectation = &SyncValidationContextMockShellExpectation{mock: mmShell.mock}
	}
	mmShell.defaultExpectation.results = &SyncValidationContextMockShellResults{s1}
	return mmShell.mock
}

//Set uses given function f to mock the SyncValidationContext.Shell method
func (mmShell *mSyncValidationContextMockShell) Set(f func() (s1 infrastructure.Shell)) *SyncValidationContextMock {
	if mmShell.defaultExpectation != nil {
		mmShell.mock.t.Fatalf("Default expectation is already set for the SyncValidationContext.Shell method")
	}

	if len(mmShell.expectations) > 0 {
		mmShell.mock.t.Fatalf("Some expectations are already set for the SyncValidationContext.Shell method")
	}

	mmShell.mock.funcShell = f
	return mmShell.mock
}

// Shell implements validation.SyncValidationContext
func (mmShell *SyncValidationContextMock) Shell() (s1 infrastructure.Shell) {
	mm_atomic.AddUint64(&mmShell.beforeShellCounter, 1)
	defer mm_atomic.AddUint64(&mmShell.afterShellCounter, 1)

	if mmShell.inspectFuncShell != nil {
		mmShell.inspectFuncShell()
	}

	if mmShell.ShellMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShell.ShellMock.defaultExpectation.Counter, 1)

		mm_results := mmShell.ShellMock.defaultExpectation.results
		if mm_results == nil {
			mmShell.t.Fatal("No results are set for the SyncValidationContextMock.Shell")
		}
		return (*mm_results).s1
	}
	if mmShell.funcShell != nil {
		return mmShell.funcShell()
	}
	mmShell.t.Fatalf("Unexpected call to SyncValidationContextMock.Shell.")
	return
}

// ShellAfterCounter returns a count of finished SyncValidationContextMock.Shell invocations
func (mmShell *SyncValidationContextMock) ShellAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.afterShellCounter)
}

// ShellBeforeCounter returns a count of SyncValidationContextMock.Shell invocations
func (mmShell *SyncValidationContextMock) ShellBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShell.beforeShellCounter)
}

// MinimockShellDone returns true if the count of the Shell invocations corresponds
// the number of defined expectations
func (m *SyncValidationContextMock) MinimockShellDone() bool {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		return false
	}
	return true
}

// MinimockShellInspect logs each unmet expectation
func (m *SyncValidationContextMock) MinimockShellInspect() {
	for _, e := range m.ShellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncValidationContextMock.Shell")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Shell")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShell != nil && mm_atomic.LoadUint64(&m.afterShellCounter) < 1 {
		m.t.Error("Expected call to SyncValidationContextMock.Shell")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SyncValidationContextMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockArgsInspect()

		m.MinimockFilesInspect()

		m.MinimockMessageInspect()

		m.MinimockOutputInspect()

		m.MinimockRepositoryInspect()

		m.MinimockShellInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SyncValidationContextMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SyncValidationContextMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArgsDone() &&
		m.MinimockFilesDone() &&
		m.MinimockMessageDone() &&
		m.MinimockOutputDone() &&
		m.MinimockRepositoryDone() &&
		m.MinimockShellDone()
}
