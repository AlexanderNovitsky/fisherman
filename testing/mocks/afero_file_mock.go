package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/spf13/afero.File -o ./testing/mocks/afero_file_mock.go

import (
	"os"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FileMock implements afero.File
type FileMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mFileMockClose

	funcName          func() (s1 string)
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mFileMockName

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mFileMockRead

	funcReadAt          func(p []byte, off int64) (n int, err error)
	inspectFuncReadAt   func(p []byte, off int64)
	afterReadAtCounter  uint64
	beforeReadAtCounter uint64
	ReadAtMock          mFileMockReadAt

	funcReaddir          func(count int) (fa1 []os.FileInfo, err error)
	inspectFuncReaddir   func(count int)
	afterReaddirCounter  uint64
	beforeReaddirCounter uint64
	ReaddirMock          mFileMockReaddir

	funcReaddirnames          func(n int) (sa1 []string, err error)
	inspectFuncReaddirnames   func(n int)
	afterReaddirnamesCounter  uint64
	beforeReaddirnamesCounter uint64
	ReaddirnamesMock          mFileMockReaddirnames

	funcSeek          func(offset int64, whence int) (i1 int64, err error)
	inspectFuncSeek   func(offset int64, whence int)
	afterSeekCounter  uint64
	beforeSeekCounter uint64
	SeekMock          mFileMockSeek

	funcStat          func() (f1 os.FileInfo, err error)
	inspectFuncStat   func()
	afterStatCounter  uint64
	beforeStatCounter uint64
	StatMock          mFileMockStat

	funcSync          func() (err error)
	inspectFuncSync   func()
	afterSyncCounter  uint64
	beforeSyncCounter uint64
	SyncMock          mFileMockSync

	funcTruncate          func(size int64) (err error)
	inspectFuncTruncate   func(size int64)
	afterTruncateCounter  uint64
	beforeTruncateCounter uint64
	TruncateMock          mFileMockTruncate

	funcWrite          func(p []byte) (n int, err error)
	inspectFuncWrite   func(p []byte)
	afterWriteCounter  uint64
	beforeWriteCounter uint64
	WriteMock          mFileMockWrite

	funcWriteAt          func(p []byte, off int64) (n int, err error)
	inspectFuncWriteAt   func(p []byte, off int64)
	afterWriteAtCounter  uint64
	beforeWriteAtCounter uint64
	WriteAtMock          mFileMockWriteAt

	funcWriteString          func(s string) (ret int, err error)
	inspectFuncWriteString   func(s string)
	afterWriteStringCounter  uint64
	beforeWriteStringCounter uint64
	WriteStringMock          mFileMockWriteString
}

// NewFileMock returns a mock for afero.File
func NewFileMock(t minimock.Tester) *FileMock {
	m := &FileMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mFileMockClose{mock: m}

	m.NameMock = mFileMockName{mock: m}

	m.ReadMock = mFileMockRead{mock: m}
	m.ReadMock.callArgs = []*FileMockReadParams{}

	m.ReadAtMock = mFileMockReadAt{mock: m}
	m.ReadAtMock.callArgs = []*FileMockReadAtParams{}

	m.ReaddirMock = mFileMockReaddir{mock: m}
	m.ReaddirMock.callArgs = []*FileMockReaddirParams{}

	m.ReaddirnamesMock = mFileMockReaddirnames{mock: m}
	m.ReaddirnamesMock.callArgs = []*FileMockReaddirnamesParams{}

	m.SeekMock = mFileMockSeek{mock: m}
	m.SeekMock.callArgs = []*FileMockSeekParams{}

	m.StatMock = mFileMockStat{mock: m}

	m.SyncMock = mFileMockSync{mock: m}

	m.TruncateMock = mFileMockTruncate{mock: m}
	m.TruncateMock.callArgs = []*FileMockTruncateParams{}

	m.WriteMock = mFileMockWrite{mock: m}
	m.WriteMock.callArgs = []*FileMockWriteParams{}

	m.WriteAtMock = mFileMockWriteAt{mock: m}
	m.WriteAtMock.callArgs = []*FileMockWriteAtParams{}

	m.WriteStringMock = mFileMockWriteString{mock: m}
	m.WriteStringMock.callArgs = []*FileMockWriteStringParams{}

	return m
}

type mFileMockClose struct {
	mock               *FileMock
	defaultExpectation *FileMockCloseExpectation
	expectations       []*FileMockCloseExpectation
}

// FileMockCloseExpectation specifies expectation struct of the File.Close
type FileMockCloseExpectation struct {
	mock *FileMock

	results *FileMockCloseResults
	Counter uint64
}

// FileMockCloseResults contains results of the File.Close
type FileMockCloseResults struct {
	err error
}

// Expect sets up expected params for File.Close
func (mmClose *mFileMockClose) Expect() *mFileMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("FileMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &FileMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the File.Close
func (mmClose *mFileMockClose) Inspect(f func()) *mFileMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for FileMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by File.Close
func (mmClose *mFileMockClose) Return(err error) *FileMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("FileMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &FileMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &FileMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the File.Close method
func (mmClose *mFileMockClose) Set(f func() (err error)) *FileMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the File.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the File.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements afero.File
func (mmClose *FileMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the FileMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to FileMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished FileMock.Close invocations
func (mmClose *FileMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of FileMock.Close invocations
func (mmClose *FileMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *FileMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to FileMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to FileMock.Close")
	}
}

type mFileMockName struct {
	mock               *FileMock
	defaultExpectation *FileMockNameExpectation
	expectations       []*FileMockNameExpectation
}

// FileMockNameExpectation specifies expectation struct of the File.Name
type FileMockNameExpectation struct {
	mock *FileMock

	results *FileMockNameResults
	Counter uint64
}

// FileMockNameResults contains results of the File.Name
type FileMockNameResults struct {
	s1 string
}

// Expect sets up expected params for File.Name
func (mmName *mFileMockName) Expect() *mFileMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("FileMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &FileMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the File.Name
func (mmName *mFileMockName) Inspect(f func()) *mFileMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for FileMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by File.Name
func (mmName *mFileMockName) Return(s1 string) *FileMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("FileMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &FileMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &FileMockNameResults{s1}
	return mmName.mock
}

//Set uses given function f to mock the File.Name method
func (mmName *mFileMockName) Set(f func() (s1 string)) *FileMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the File.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the File.Name method")
	}

	mmName.mock.funcName = f
	return mmName.mock
}

// Name implements afero.File
func (mmName *FileMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the FileMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to FileMock.Name.")
	return
}

// NameAfterCounter returns a count of finished FileMock.Name invocations
func (mmName *FileMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of FileMock.Name invocations
func (mmName *FileMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockNameDone() bool {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockNameInspect logs each unmet expectation
func (m *FileMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Name")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to FileMock.Name")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to FileMock.Name")
	}
}

type mFileMockRead struct {
	mock               *FileMock
	defaultExpectation *FileMockReadExpectation
	expectations       []*FileMockReadExpectation

	callArgs []*FileMockReadParams
	mutex    sync.RWMutex
}

// FileMockReadExpectation specifies expectation struct of the File.Read
type FileMockReadExpectation struct {
	mock    *FileMock
	params  *FileMockReadParams
	results *FileMockReadResults
	Counter uint64
}

// FileMockReadParams contains parameters of the File.Read
type FileMockReadParams struct {
	p []byte
}

// FileMockReadResults contains results of the File.Read
type FileMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.Read
func (mmRead *mFileMockRead) Expect(p []byte) *mFileMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FileMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &FileMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the File.Read
func (mmRead *mFileMockRead) Inspect(f func(p []byte)) *mFileMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for FileMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by File.Read
func (mmRead *mFileMockRead) Return(n int, err error) *FileMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FileMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &FileMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the File.Read method
func (mmRead *mFileMockRead) Set(f func(p []byte) (n int, err error)) *FileMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the File.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the File.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the File.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mFileMockRead) When(p []byte) *FileMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	expectation := &FileMockReadExpectation{
		mock:   mmRead.mock,
		params: &FileMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up File.Read return parameters for the expectation previously defined by the When method
func (e *FileMockReadExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockReadResults{n, err}
	return e.mock
}

// Read implements afero.File
func (mmRead *FileMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	mm_params := &FileMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, mm_params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRead.ReadMock.defaultExpectation.params
		mm_got := FileMockReadParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRead.t.Errorf("FileMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRead.ReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRead.t.Fatal("No results are set for the FileMock.Read")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to FileMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished FileMock.Read invocations
func (mmRead *FileMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of FileMock.Read invocations
func (mmRead *FileMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mFileMockRead) Calls() []*FileMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*FileMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *FileMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Read")
		} else {
			m.t.Errorf("Expected call to FileMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to FileMock.Read")
	}
}

type mFileMockReadAt struct {
	mock               *FileMock
	defaultExpectation *FileMockReadAtExpectation
	expectations       []*FileMockReadAtExpectation

	callArgs []*FileMockReadAtParams
	mutex    sync.RWMutex
}

// FileMockReadAtExpectation specifies expectation struct of the File.ReadAt
type FileMockReadAtExpectation struct {
	mock    *FileMock
	params  *FileMockReadAtParams
	results *FileMockReadAtResults
	Counter uint64
}

// FileMockReadAtParams contains parameters of the File.ReadAt
type FileMockReadAtParams struct {
	p   []byte
	off int64
}

// FileMockReadAtResults contains results of the File.ReadAt
type FileMockReadAtResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.ReadAt
func (mmReadAt *mFileMockReadAt) Expect(p []byte, off int64) *mFileMockReadAt {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	if mmReadAt.defaultExpectation == nil {
		mmReadAt.defaultExpectation = &FileMockReadAtExpectation{}
	}

	mmReadAt.defaultExpectation.params = &FileMockReadAtParams{p, off}
	for _, e := range mmReadAt.expectations {
		if minimock.Equal(e.params, mmReadAt.defaultExpectation.params) {
			mmReadAt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadAt.defaultExpectation.params)
		}
	}

	return mmReadAt
}

// Inspect accepts an inspector function that has same arguments as the File.ReadAt
func (mmReadAt *mFileMockReadAt) Inspect(f func(p []byte, off int64)) *mFileMockReadAt {
	if mmReadAt.mock.inspectFuncReadAt != nil {
		mmReadAt.mock.t.Fatalf("Inspect function is already set for FileMock.ReadAt")
	}

	mmReadAt.mock.inspectFuncReadAt = f

	return mmReadAt
}

// Return sets up results that will be returned by File.ReadAt
func (mmReadAt *mFileMockReadAt) Return(n int, err error) *FileMock {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	if mmReadAt.defaultExpectation == nil {
		mmReadAt.defaultExpectation = &FileMockReadAtExpectation{mock: mmReadAt.mock}
	}
	mmReadAt.defaultExpectation.results = &FileMockReadAtResults{n, err}
	return mmReadAt.mock
}

//Set uses given function f to mock the File.ReadAt method
func (mmReadAt *mFileMockReadAt) Set(f func(p []byte, off int64) (n int, err error)) *FileMock {
	if mmReadAt.defaultExpectation != nil {
		mmReadAt.mock.t.Fatalf("Default expectation is already set for the File.ReadAt method")
	}

	if len(mmReadAt.expectations) > 0 {
		mmReadAt.mock.t.Fatalf("Some expectations are already set for the File.ReadAt method")
	}

	mmReadAt.mock.funcReadAt = f
	return mmReadAt.mock
}

// When sets expectation for the File.ReadAt which will trigger the result defined by the following
// Then helper
func (mmReadAt *mFileMockReadAt) When(p []byte, off int64) *FileMockReadAtExpectation {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	expectation := &FileMockReadAtExpectation{
		mock:   mmReadAt.mock,
		params: &FileMockReadAtParams{p, off},
	}
	mmReadAt.expectations = append(mmReadAt.expectations, expectation)
	return expectation
}

// Then sets up File.ReadAt return parameters for the expectation previously defined by the When method
func (e *FileMockReadAtExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockReadAtResults{n, err}
	return e.mock
}

// ReadAt implements afero.File
func (mmReadAt *FileMock) ReadAt(p []byte, off int64) (n int, err error) {
	mm_atomic.AddUint64(&mmReadAt.beforeReadAtCounter, 1)
	defer mm_atomic.AddUint64(&mmReadAt.afterReadAtCounter, 1)

	if mmReadAt.inspectFuncReadAt != nil {
		mmReadAt.inspectFuncReadAt(p, off)
	}

	mm_params := &FileMockReadAtParams{p, off}

	// Record call args
	mmReadAt.ReadAtMock.mutex.Lock()
	mmReadAt.ReadAtMock.callArgs = append(mmReadAt.ReadAtMock.callArgs, mm_params)
	mmReadAt.ReadAtMock.mutex.Unlock()

	for _, e := range mmReadAt.ReadAtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmReadAt.ReadAtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadAt.ReadAtMock.defaultExpectation.Counter, 1)
		mm_want := mmReadAt.ReadAtMock.defaultExpectation.params
		mm_got := FileMockReadAtParams{p, off}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadAt.t.Errorf("FileMock.ReadAt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadAt.ReadAtMock.defaultExpectation.results
		if mm_results == nil {
			mmReadAt.t.Fatal("No results are set for the FileMock.ReadAt")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmReadAt.funcReadAt != nil {
		return mmReadAt.funcReadAt(p, off)
	}
	mmReadAt.t.Fatalf("Unexpected call to FileMock.ReadAt. %v %v", p, off)
	return
}

// ReadAtAfterCounter returns a count of finished FileMock.ReadAt invocations
func (mmReadAt *FileMock) ReadAtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadAt.afterReadAtCounter)
}

// ReadAtBeforeCounter returns a count of FileMock.ReadAt invocations
func (mmReadAt *FileMock) ReadAtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadAt.beforeReadAtCounter)
}

// Calls returns a list of arguments used in each call to FileMock.ReadAt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadAt *mFileMockReadAt) Calls() []*FileMockReadAtParams {
	mmReadAt.mutex.RLock()

	argCopy := make([]*FileMockReadAtParams, len(mmReadAt.callArgs))
	copy(argCopy, mmReadAt.callArgs)

	mmReadAt.mutex.RUnlock()

	return argCopy
}

// MinimockReadAtDone returns true if the count of the ReadAt invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReadAtDone() bool {
	for _, e := range m.ReadAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadAt != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadAtInspect logs each unmet expectation
func (m *FileMock) MinimockReadAtInspect() {
	for _, e := range m.ReadAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.ReadAt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		if m.ReadAtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.ReadAt")
		} else {
			m.t.Errorf("Expected call to FileMock.ReadAt with params: %#v", *m.ReadAtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadAt != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		m.t.Error("Expected call to FileMock.ReadAt")
	}
}

type mFileMockReaddir struct {
	mock               *FileMock
	defaultExpectation *FileMockReaddirExpectation
	expectations       []*FileMockReaddirExpectation

	callArgs []*FileMockReaddirParams
	mutex    sync.RWMutex
}

// FileMockReaddirExpectation specifies expectation struct of the File.Readdir
type FileMockReaddirExpectation struct {
	mock    *FileMock
	params  *FileMockReaddirParams
	results *FileMockReaddirResults
	Counter uint64
}

// FileMockReaddirParams contains parameters of the File.Readdir
type FileMockReaddirParams struct {
	count int
}

// FileMockReaddirResults contains results of the File.Readdir
type FileMockReaddirResults struct {
	fa1 []os.FileInfo
	err error
}

// Expect sets up expected params for File.Readdir
func (mmReaddir *mFileMockReaddir) Expect(count int) *mFileMockReaddir {
	if mmReaddir.mock.funcReaddir != nil {
		mmReaddir.mock.t.Fatalf("FileMock.Readdir mock is already set by Set")
	}

	if mmReaddir.defaultExpectation == nil {
		mmReaddir.defaultExpectation = &FileMockReaddirExpectation{}
	}

	mmReaddir.defaultExpectation.params = &FileMockReaddirParams{count}
	for _, e := range mmReaddir.expectations {
		if minimock.Equal(e.params, mmReaddir.defaultExpectation.params) {
			mmReaddir.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReaddir.defaultExpectation.params)
		}
	}

	return mmReaddir
}

// Inspect accepts an inspector function that has same arguments as the File.Readdir
func (mmReaddir *mFileMockReaddir) Inspect(f func(count int)) *mFileMockReaddir {
	if mmReaddir.mock.inspectFuncReaddir != nil {
		mmReaddir.mock.t.Fatalf("Inspect function is already set for FileMock.Readdir")
	}

	mmReaddir.mock.inspectFuncReaddir = f

	return mmReaddir
}

// Return sets up results that will be returned by File.Readdir
func (mmReaddir *mFileMockReaddir) Return(fa1 []os.FileInfo, err error) *FileMock {
	if mmReaddir.mock.funcReaddir != nil {
		mmReaddir.mock.t.Fatalf("FileMock.Readdir mock is already set by Set")
	}

	if mmReaddir.defaultExpectation == nil {
		mmReaddir.defaultExpectation = &FileMockReaddirExpectation{mock: mmReaddir.mock}
	}
	mmReaddir.defaultExpectation.results = &FileMockReaddirResults{fa1, err}
	return mmReaddir.mock
}

//Set uses given function f to mock the File.Readdir method
func (mmReaddir *mFileMockReaddir) Set(f func(count int) (fa1 []os.FileInfo, err error)) *FileMock {
	if mmReaddir.defaultExpectation != nil {
		mmReaddir.mock.t.Fatalf("Default expectation is already set for the File.Readdir method")
	}

	if len(mmReaddir.expectations) > 0 {
		mmReaddir.mock.t.Fatalf("Some expectations are already set for the File.Readdir method")
	}

	mmReaddir.mock.funcReaddir = f
	return mmReaddir.mock
}

// When sets expectation for the File.Readdir which will trigger the result defined by the following
// Then helper
func (mmReaddir *mFileMockReaddir) When(count int) *FileMockReaddirExpectation {
	if mmReaddir.mock.funcReaddir != nil {
		mmReaddir.mock.t.Fatalf("FileMock.Readdir mock is already set by Set")
	}

	expectation := &FileMockReaddirExpectation{
		mock:   mmReaddir.mock,
		params: &FileMockReaddirParams{count},
	}
	mmReaddir.expectations = append(mmReaddir.expectations, expectation)
	return expectation
}

// Then sets up File.Readdir return parameters for the expectation previously defined by the When method
func (e *FileMockReaddirExpectation) Then(fa1 []os.FileInfo, err error) *FileMock {
	e.results = &FileMockReaddirResults{fa1, err}
	return e.mock
}

// Readdir implements afero.File
func (mmReaddir *FileMock) Readdir(count int) (fa1 []os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmReaddir.beforeReaddirCounter, 1)
	defer mm_atomic.AddUint64(&mmReaddir.afterReaddirCounter, 1)

	if mmReaddir.inspectFuncReaddir != nil {
		mmReaddir.inspectFuncReaddir(count)
	}

	mm_params := &FileMockReaddirParams{count}

	// Record call args
	mmReaddir.ReaddirMock.mutex.Lock()
	mmReaddir.ReaddirMock.callArgs = append(mmReaddir.ReaddirMock.callArgs, mm_params)
	mmReaddir.ReaddirMock.mutex.Unlock()

	for _, e := range mmReaddir.ReaddirMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmReaddir.ReaddirMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReaddir.ReaddirMock.defaultExpectation.Counter, 1)
		mm_want := mmReaddir.ReaddirMock.defaultExpectation.params
		mm_got := FileMockReaddirParams{count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReaddir.t.Errorf("FileMock.Readdir got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReaddir.ReaddirMock.defaultExpectation.results
		if mm_results == nil {
			mmReaddir.t.Fatal("No results are set for the FileMock.Readdir")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmReaddir.funcReaddir != nil {
		return mmReaddir.funcReaddir(count)
	}
	mmReaddir.t.Fatalf("Unexpected call to FileMock.Readdir. %v", count)
	return
}

// ReaddirAfterCounter returns a count of finished FileMock.Readdir invocations
func (mmReaddir *FileMock) ReaddirAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReaddir.afterReaddirCounter)
}

// ReaddirBeforeCounter returns a count of FileMock.Readdir invocations
func (mmReaddir *FileMock) ReaddirBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReaddir.beforeReaddirCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Readdir.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReaddir *mFileMockReaddir) Calls() []*FileMockReaddirParams {
	mmReaddir.mutex.RLock()

	argCopy := make([]*FileMockReaddirParams, len(mmReaddir.callArgs))
	copy(argCopy, mmReaddir.callArgs)

	mmReaddir.mutex.RUnlock()

	return argCopy
}

// MinimockReaddirDone returns true if the count of the Readdir invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReaddirDone() bool {
	for _, e := range m.ReaddirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaddirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaddirCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReaddir != nil && mm_atomic.LoadUint64(&m.afterReaddirCounter) < 1 {
		return false
	}
	return true
}

// MinimockReaddirInspect logs each unmet expectation
func (m *FileMock) MinimockReaddirInspect() {
	for _, e := range m.ReaddirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Readdir with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaddirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaddirCounter) < 1 {
		if m.ReaddirMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Readdir")
		} else {
			m.t.Errorf("Expected call to FileMock.Readdir with params: %#v", *m.ReaddirMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReaddir != nil && mm_atomic.LoadUint64(&m.afterReaddirCounter) < 1 {
		m.t.Error("Expected call to FileMock.Readdir")
	}
}

type mFileMockReaddirnames struct {
	mock               *FileMock
	defaultExpectation *FileMockReaddirnamesExpectation
	expectations       []*FileMockReaddirnamesExpectation

	callArgs []*FileMockReaddirnamesParams
	mutex    sync.RWMutex
}

// FileMockReaddirnamesExpectation specifies expectation struct of the File.Readdirnames
type FileMockReaddirnamesExpectation struct {
	mock    *FileMock
	params  *FileMockReaddirnamesParams
	results *FileMockReaddirnamesResults
	Counter uint64
}

// FileMockReaddirnamesParams contains parameters of the File.Readdirnames
type FileMockReaddirnamesParams struct {
	n int
}

// FileMockReaddirnamesResults contains results of the File.Readdirnames
type FileMockReaddirnamesResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for File.Readdirnames
func (mmReaddirnames *mFileMockReaddirnames) Expect(n int) *mFileMockReaddirnames {
	if mmReaddirnames.mock.funcReaddirnames != nil {
		mmReaddirnames.mock.t.Fatalf("FileMock.Readdirnames mock is already set by Set")
	}

	if mmReaddirnames.defaultExpectation == nil {
		mmReaddirnames.defaultExpectation = &FileMockReaddirnamesExpectation{}
	}

	mmReaddirnames.defaultExpectation.params = &FileMockReaddirnamesParams{n}
	for _, e := range mmReaddirnames.expectations {
		if minimock.Equal(e.params, mmReaddirnames.defaultExpectation.params) {
			mmReaddirnames.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReaddirnames.defaultExpectation.params)
		}
	}

	return mmReaddirnames
}

// Inspect accepts an inspector function that has same arguments as the File.Readdirnames
func (mmReaddirnames *mFileMockReaddirnames) Inspect(f func(n int)) *mFileMockReaddirnames {
	if mmReaddirnames.mock.inspectFuncReaddirnames != nil {
		mmReaddirnames.mock.t.Fatalf("Inspect function is already set for FileMock.Readdirnames")
	}

	mmReaddirnames.mock.inspectFuncReaddirnames = f

	return mmReaddirnames
}

// Return sets up results that will be returned by File.Readdirnames
func (mmReaddirnames *mFileMockReaddirnames) Return(sa1 []string, err error) *FileMock {
	if mmReaddirnames.mock.funcReaddirnames != nil {
		mmReaddirnames.mock.t.Fatalf("FileMock.Readdirnames mock is already set by Set")
	}

	if mmReaddirnames.defaultExpectation == nil {
		mmReaddirnames.defaultExpectation = &FileMockReaddirnamesExpectation{mock: mmReaddirnames.mock}
	}
	mmReaddirnames.defaultExpectation.results = &FileMockReaddirnamesResults{sa1, err}
	return mmReaddirnames.mock
}

//Set uses given function f to mock the File.Readdirnames method
func (mmReaddirnames *mFileMockReaddirnames) Set(f func(n int) (sa1 []string, err error)) *FileMock {
	if mmReaddirnames.defaultExpectation != nil {
		mmReaddirnames.mock.t.Fatalf("Default expectation is already set for the File.Readdirnames method")
	}

	if len(mmReaddirnames.expectations) > 0 {
		mmReaddirnames.mock.t.Fatalf("Some expectations are already set for the File.Readdirnames method")
	}

	mmReaddirnames.mock.funcReaddirnames = f
	return mmReaddirnames.mock
}

// When sets expectation for the File.Readdirnames which will trigger the result defined by the following
// Then helper
func (mmReaddirnames *mFileMockReaddirnames) When(n int) *FileMockReaddirnamesExpectation {
	if mmReaddirnames.mock.funcReaddirnames != nil {
		mmReaddirnames.mock.t.Fatalf("FileMock.Readdirnames mock is already set by Set")
	}

	expectation := &FileMockReaddirnamesExpectation{
		mock:   mmReaddirnames.mock,
		params: &FileMockReaddirnamesParams{n},
	}
	mmReaddirnames.expectations = append(mmReaddirnames.expectations, expectation)
	return expectation
}

// Then sets up File.Readdirnames return parameters for the expectation previously defined by the When method
func (e *FileMockReaddirnamesExpectation) Then(sa1 []string, err error) *FileMock {
	e.results = &FileMockReaddirnamesResults{sa1, err}
	return e.mock
}

// Readdirnames implements afero.File
func (mmReaddirnames *FileMock) Readdirnames(n int) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmReaddirnames.beforeReaddirnamesCounter, 1)
	defer mm_atomic.AddUint64(&mmReaddirnames.afterReaddirnamesCounter, 1)

	if mmReaddirnames.inspectFuncReaddirnames != nil {
		mmReaddirnames.inspectFuncReaddirnames(n)
	}

	mm_params := &FileMockReaddirnamesParams{n}

	// Record call args
	mmReaddirnames.ReaddirnamesMock.mutex.Lock()
	mmReaddirnames.ReaddirnamesMock.callArgs = append(mmReaddirnames.ReaddirnamesMock.callArgs, mm_params)
	mmReaddirnames.ReaddirnamesMock.mutex.Unlock()

	for _, e := range mmReaddirnames.ReaddirnamesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmReaddirnames.ReaddirnamesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReaddirnames.ReaddirnamesMock.defaultExpectation.Counter, 1)
		mm_want := mmReaddirnames.ReaddirnamesMock.defaultExpectation.params
		mm_got := FileMockReaddirnamesParams{n}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReaddirnames.t.Errorf("FileMock.Readdirnames got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReaddirnames.ReaddirnamesMock.defaultExpectation.results
		if mm_results == nil {
			mmReaddirnames.t.Fatal("No results are set for the FileMock.Readdirnames")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmReaddirnames.funcReaddirnames != nil {
		return mmReaddirnames.funcReaddirnames(n)
	}
	mmReaddirnames.t.Fatalf("Unexpected call to FileMock.Readdirnames. %v", n)
	return
}

// ReaddirnamesAfterCounter returns a count of finished FileMock.Readdirnames invocations
func (mmReaddirnames *FileMock) ReaddirnamesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReaddirnames.afterReaddirnamesCounter)
}

// ReaddirnamesBeforeCounter returns a count of FileMock.Readdirnames invocations
func (mmReaddirnames *FileMock) ReaddirnamesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReaddirnames.beforeReaddirnamesCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Readdirnames.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReaddirnames *mFileMockReaddirnames) Calls() []*FileMockReaddirnamesParams {
	mmReaddirnames.mutex.RLock()

	argCopy := make([]*FileMockReaddirnamesParams, len(mmReaddirnames.callArgs))
	copy(argCopy, mmReaddirnames.callArgs)

	mmReaddirnames.mutex.RUnlock()

	return argCopy
}

// MinimockReaddirnamesDone returns true if the count of the Readdirnames invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReaddirnamesDone() bool {
	for _, e := range m.ReaddirnamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaddirnamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaddirnamesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReaddirnames != nil && mm_atomic.LoadUint64(&m.afterReaddirnamesCounter) < 1 {
		return false
	}
	return true
}

// MinimockReaddirnamesInspect logs each unmet expectation
func (m *FileMock) MinimockReaddirnamesInspect() {
	for _, e := range m.ReaddirnamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Readdirnames with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaddirnamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaddirnamesCounter) < 1 {
		if m.ReaddirnamesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Readdirnames")
		} else {
			m.t.Errorf("Expected call to FileMock.Readdirnames with params: %#v", *m.ReaddirnamesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReaddirnames != nil && mm_atomic.LoadUint64(&m.afterReaddirnamesCounter) < 1 {
		m.t.Error("Expected call to FileMock.Readdirnames")
	}
}

type mFileMockSeek struct {
	mock               *FileMock
	defaultExpectation *FileMockSeekExpectation
	expectations       []*FileMockSeekExpectation

	callArgs []*FileMockSeekParams
	mutex    sync.RWMutex
}

// FileMockSeekExpectation specifies expectation struct of the File.Seek
type FileMockSeekExpectation struct {
	mock    *FileMock
	params  *FileMockSeekParams
	results *FileMockSeekResults
	Counter uint64
}

// FileMockSeekParams contains parameters of the File.Seek
type FileMockSeekParams struct {
	offset int64
	whence int
}

// FileMockSeekResults contains results of the File.Seek
type FileMockSeekResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for File.Seek
func (mmSeek *mFileMockSeek) Expect(offset int64, whence int) *mFileMockSeek {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	if mmSeek.defaultExpectation == nil {
		mmSeek.defaultExpectation = &FileMockSeekExpectation{}
	}

	mmSeek.defaultExpectation.params = &FileMockSeekParams{offset, whence}
	for _, e := range mmSeek.expectations {
		if minimock.Equal(e.params, mmSeek.defaultExpectation.params) {
			mmSeek.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSeek.defaultExpectation.params)
		}
	}

	return mmSeek
}

// Inspect accepts an inspector function that has same arguments as the File.Seek
func (mmSeek *mFileMockSeek) Inspect(f func(offset int64, whence int)) *mFileMockSeek {
	if mmSeek.mock.inspectFuncSeek != nil {
		mmSeek.mock.t.Fatalf("Inspect function is already set for FileMock.Seek")
	}

	mmSeek.mock.inspectFuncSeek = f

	return mmSeek
}

// Return sets up results that will be returned by File.Seek
func (mmSeek *mFileMockSeek) Return(i1 int64, err error) *FileMock {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	if mmSeek.defaultExpectation == nil {
		mmSeek.defaultExpectation = &FileMockSeekExpectation{mock: mmSeek.mock}
	}
	mmSeek.defaultExpectation.results = &FileMockSeekResults{i1, err}
	return mmSeek.mock
}

//Set uses given function f to mock the File.Seek method
func (mmSeek *mFileMockSeek) Set(f func(offset int64, whence int) (i1 int64, err error)) *FileMock {
	if mmSeek.defaultExpectation != nil {
		mmSeek.mock.t.Fatalf("Default expectation is already set for the File.Seek method")
	}

	if len(mmSeek.expectations) > 0 {
		mmSeek.mock.t.Fatalf("Some expectations are already set for the File.Seek method")
	}

	mmSeek.mock.funcSeek = f
	return mmSeek.mock
}

// When sets expectation for the File.Seek which will trigger the result defined by the following
// Then helper
func (mmSeek *mFileMockSeek) When(offset int64, whence int) *FileMockSeekExpectation {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	expectation := &FileMockSeekExpectation{
		mock:   mmSeek.mock,
		params: &FileMockSeekParams{offset, whence},
	}
	mmSeek.expectations = append(mmSeek.expectations, expectation)
	return expectation
}

// Then sets up File.Seek return parameters for the expectation previously defined by the When method
func (e *FileMockSeekExpectation) Then(i1 int64, err error) *FileMock {
	e.results = &FileMockSeekResults{i1, err}
	return e.mock
}

// Seek implements afero.File
func (mmSeek *FileMock) Seek(offset int64, whence int) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSeek.beforeSeekCounter, 1)
	defer mm_atomic.AddUint64(&mmSeek.afterSeekCounter, 1)

	if mmSeek.inspectFuncSeek != nil {
		mmSeek.inspectFuncSeek(offset, whence)
	}

	mm_params := &FileMockSeekParams{offset, whence}

	// Record call args
	mmSeek.SeekMock.mutex.Lock()
	mmSeek.SeekMock.callArgs = append(mmSeek.SeekMock.callArgs, mm_params)
	mmSeek.SeekMock.mutex.Unlock()

	for _, e := range mmSeek.SeekMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSeek.SeekMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSeek.SeekMock.defaultExpectation.Counter, 1)
		mm_want := mmSeek.SeekMock.defaultExpectation.params
		mm_got := FileMockSeekParams{offset, whence}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSeek.t.Errorf("FileMock.Seek got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSeek.SeekMock.defaultExpectation.results
		if mm_results == nil {
			mmSeek.t.Fatal("No results are set for the FileMock.Seek")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSeek.funcSeek != nil {
		return mmSeek.funcSeek(offset, whence)
	}
	mmSeek.t.Fatalf("Unexpected call to FileMock.Seek. %v %v", offset, whence)
	return
}

// SeekAfterCounter returns a count of finished FileMock.Seek invocations
func (mmSeek *FileMock) SeekAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSeek.afterSeekCounter)
}

// SeekBeforeCounter returns a count of FileMock.Seek invocations
func (mmSeek *FileMock) SeekBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSeek.beforeSeekCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Seek.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSeek *mFileMockSeek) Calls() []*FileMockSeekParams {
	mmSeek.mutex.RLock()

	argCopy := make([]*FileMockSeekParams, len(mmSeek.callArgs))
	copy(argCopy, mmSeek.callArgs)

	mmSeek.mutex.RUnlock()

	return argCopy
}

// MinimockSeekDone returns true if the count of the Seek invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockSeekDone() bool {
	for _, e := range m.SeekMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SeekMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSeek != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		return false
	}
	return true
}

// MinimockSeekInspect logs each unmet expectation
func (m *FileMock) MinimockSeekInspect() {
	for _, e := range m.SeekMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Seek with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SeekMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		if m.SeekMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Seek")
		} else {
			m.t.Errorf("Expected call to FileMock.Seek with params: %#v", *m.SeekMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSeek != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		m.t.Error("Expected call to FileMock.Seek")
	}
}

type mFileMockStat struct {
	mock               *FileMock
	defaultExpectation *FileMockStatExpectation
	expectations       []*FileMockStatExpectation
}

// FileMockStatExpectation specifies expectation struct of the File.Stat
type FileMockStatExpectation struct {
	mock *FileMock

	results *FileMockStatResults
	Counter uint64
}

// FileMockStatResults contains results of the File.Stat
type FileMockStatResults struct {
	f1  os.FileInfo
	err error
}

// Expect sets up expected params for File.Stat
func (mmStat *mFileMockStat) Expect() *mFileMockStat {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FileMockStatExpectation{}
	}

	return mmStat
}

// Inspect accepts an inspector function that has same arguments as the File.Stat
func (mmStat *mFileMockStat) Inspect(f func()) *mFileMockStat {
	if mmStat.mock.inspectFuncStat != nil {
		mmStat.mock.t.Fatalf("Inspect function is already set for FileMock.Stat")
	}

	mmStat.mock.inspectFuncStat = f

	return mmStat
}

// Return sets up results that will be returned by File.Stat
func (mmStat *mFileMockStat) Return(f1 os.FileInfo, err error) *FileMock {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FileMockStatExpectation{mock: mmStat.mock}
	}
	mmStat.defaultExpectation.results = &FileMockStatResults{f1, err}
	return mmStat.mock
}

//Set uses given function f to mock the File.Stat method
func (mmStat *mFileMockStat) Set(f func() (f1 os.FileInfo, err error)) *FileMock {
	if mmStat.defaultExpectation != nil {
		mmStat.mock.t.Fatalf("Default expectation is already set for the File.Stat method")
	}

	if len(mmStat.expectations) > 0 {
		mmStat.mock.t.Fatalf("Some expectations are already set for the File.Stat method")
	}

	mmStat.mock.funcStat = f
	return mmStat.mock
}

// Stat implements afero.File
func (mmStat *FileMock) Stat() (f1 os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmStat.beforeStatCounter, 1)
	defer mm_atomic.AddUint64(&mmStat.afterStatCounter, 1)

	if mmStat.inspectFuncStat != nil {
		mmStat.inspectFuncStat()
	}

	if mmStat.StatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStat.StatMock.defaultExpectation.Counter, 1)

		mm_results := mmStat.StatMock.defaultExpectation.results
		if mm_results == nil {
			mmStat.t.Fatal("No results are set for the FileMock.Stat")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmStat.funcStat != nil {
		return mmStat.funcStat()
	}
	mmStat.t.Fatalf("Unexpected call to FileMock.Stat.")
	return
}

// StatAfterCounter returns a count of finished FileMock.Stat invocations
func (mmStat *FileMock) StatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.afterStatCounter)
}

// StatBeforeCounter returns a count of FileMock.Stat invocations
func (mmStat *FileMock) StatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.beforeStatCounter)
}

// MinimockStatDone returns true if the count of the Stat invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockStatDone() bool {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	return true
}

// MinimockStatInspect logs each unmet expectation
func (m *FileMock) MinimockStatInspect() {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Stat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		m.t.Error("Expected call to FileMock.Stat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		m.t.Error("Expected call to FileMock.Stat")
	}
}

type mFileMockSync struct {
	mock               *FileMock
	defaultExpectation *FileMockSyncExpectation
	expectations       []*FileMockSyncExpectation
}

// FileMockSyncExpectation specifies expectation struct of the File.Sync
type FileMockSyncExpectation struct {
	mock *FileMock

	results *FileMockSyncResults
	Counter uint64
}

// FileMockSyncResults contains results of the File.Sync
type FileMockSyncResults struct {
	err error
}

// Expect sets up expected params for File.Sync
func (mmSync *mFileMockSync) Expect() *mFileMockSync {
	if mmSync.mock.funcSync != nil {
		mmSync.mock.t.Fatalf("FileMock.Sync mock is already set by Set")
	}

	if mmSync.defaultExpectation == nil {
		mmSync.defaultExpectation = &FileMockSyncExpectation{}
	}

	return mmSync
}

// Inspect accepts an inspector function that has same arguments as the File.Sync
func (mmSync *mFileMockSync) Inspect(f func()) *mFileMockSync {
	if mmSync.mock.inspectFuncSync != nil {
		mmSync.mock.t.Fatalf("Inspect function is already set for FileMock.Sync")
	}

	mmSync.mock.inspectFuncSync = f

	return mmSync
}

// Return sets up results that will be returned by File.Sync
func (mmSync *mFileMockSync) Return(err error) *FileMock {
	if mmSync.mock.funcSync != nil {
		mmSync.mock.t.Fatalf("FileMock.Sync mock is already set by Set")
	}

	if mmSync.defaultExpectation == nil {
		mmSync.defaultExpectation = &FileMockSyncExpectation{mock: mmSync.mock}
	}
	mmSync.defaultExpectation.results = &FileMockSyncResults{err}
	return mmSync.mock
}

//Set uses given function f to mock the File.Sync method
func (mmSync *mFileMockSync) Set(f func() (err error)) *FileMock {
	if mmSync.defaultExpectation != nil {
		mmSync.mock.t.Fatalf("Default expectation is already set for the File.Sync method")
	}

	if len(mmSync.expectations) > 0 {
		mmSync.mock.t.Fatalf("Some expectations are already set for the File.Sync method")
	}

	mmSync.mock.funcSync = f
	return mmSync.mock
}

// Sync implements afero.File
func (mmSync *FileMock) Sync() (err error) {
	mm_atomic.AddUint64(&mmSync.beforeSyncCounter, 1)
	defer mm_atomic.AddUint64(&mmSync.afterSyncCounter, 1)

	if mmSync.inspectFuncSync != nil {
		mmSync.inspectFuncSync()
	}

	if mmSync.SyncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSync.SyncMock.defaultExpectation.Counter, 1)

		mm_results := mmSync.SyncMock.defaultExpectation.results
		if mm_results == nil {
			mmSync.t.Fatal("No results are set for the FileMock.Sync")
		}
		return (*mm_results).err
	}
	if mmSync.funcSync != nil {
		return mmSync.funcSync()
	}
	mmSync.t.Fatalf("Unexpected call to FileMock.Sync.")
	return
}

// SyncAfterCounter returns a count of finished FileMock.Sync invocations
func (mmSync *FileMock) SyncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSync.afterSyncCounter)
}

// SyncBeforeCounter returns a count of FileMock.Sync invocations
func (mmSync *FileMock) SyncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSync.beforeSyncCounter)
}

// MinimockSyncDone returns true if the count of the Sync invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockSyncDone() bool {
	for _, e := range m.SyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSync != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		return false
	}
	return true
}

// MinimockSyncInspect logs each unmet expectation
func (m *FileMock) MinimockSyncInspect() {
	for _, e := range m.SyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Sync")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		m.t.Error("Expected call to FileMock.Sync")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSync != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		m.t.Error("Expected call to FileMock.Sync")
	}
}

type mFileMockTruncate struct {
	mock               *FileMock
	defaultExpectation *FileMockTruncateExpectation
	expectations       []*FileMockTruncateExpectation

	callArgs []*FileMockTruncateParams
	mutex    sync.RWMutex
}

// FileMockTruncateExpectation specifies expectation struct of the File.Truncate
type FileMockTruncateExpectation struct {
	mock    *FileMock
	params  *FileMockTruncateParams
	results *FileMockTruncateResults
	Counter uint64
}

// FileMockTruncateParams contains parameters of the File.Truncate
type FileMockTruncateParams struct {
	size int64
}

// FileMockTruncateResults contains results of the File.Truncate
type FileMockTruncateResults struct {
	err error
}

// Expect sets up expected params for File.Truncate
func (mmTruncate *mFileMockTruncate) Expect(size int64) *mFileMockTruncate {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	if mmTruncate.defaultExpectation == nil {
		mmTruncate.defaultExpectation = &FileMockTruncateExpectation{}
	}

	mmTruncate.defaultExpectation.params = &FileMockTruncateParams{size}
	for _, e := range mmTruncate.expectations {
		if minimock.Equal(e.params, mmTruncate.defaultExpectation.params) {
			mmTruncate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTruncate.defaultExpectation.params)
		}
	}

	return mmTruncate
}

// Inspect accepts an inspector function that has same arguments as the File.Truncate
func (mmTruncate *mFileMockTruncate) Inspect(f func(size int64)) *mFileMockTruncate {
	if mmTruncate.mock.inspectFuncTruncate != nil {
		mmTruncate.mock.t.Fatalf("Inspect function is already set for FileMock.Truncate")
	}

	mmTruncate.mock.inspectFuncTruncate = f

	return mmTruncate
}

// Return sets up results that will be returned by File.Truncate
func (mmTruncate *mFileMockTruncate) Return(err error) *FileMock {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	if mmTruncate.defaultExpectation == nil {
		mmTruncate.defaultExpectation = &FileMockTruncateExpectation{mock: mmTruncate.mock}
	}
	mmTruncate.defaultExpectation.results = &FileMockTruncateResults{err}
	return mmTruncate.mock
}

//Set uses given function f to mock the File.Truncate method
func (mmTruncate *mFileMockTruncate) Set(f func(size int64) (err error)) *FileMock {
	if mmTruncate.defaultExpectation != nil {
		mmTruncate.mock.t.Fatalf("Default expectation is already set for the File.Truncate method")
	}

	if len(mmTruncate.expectations) > 0 {
		mmTruncate.mock.t.Fatalf("Some expectations are already set for the File.Truncate method")
	}

	mmTruncate.mock.funcTruncate = f
	return mmTruncate.mock
}

// When sets expectation for the File.Truncate which will trigger the result defined by the following
// Then helper
func (mmTruncate *mFileMockTruncate) When(size int64) *FileMockTruncateExpectation {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	expectation := &FileMockTruncateExpectation{
		mock:   mmTruncate.mock,
		params: &FileMockTruncateParams{size},
	}
	mmTruncate.expectations = append(mmTruncate.expectations, expectation)
	return expectation
}

// Then sets up File.Truncate return parameters for the expectation previously defined by the When method
func (e *FileMockTruncateExpectation) Then(err error) *FileMock {
	e.results = &FileMockTruncateResults{err}
	return e.mock
}

// Truncate implements afero.File
func (mmTruncate *FileMock) Truncate(size int64) (err error) {
	mm_atomic.AddUint64(&mmTruncate.beforeTruncateCounter, 1)
	defer mm_atomic.AddUint64(&mmTruncate.afterTruncateCounter, 1)

	if mmTruncate.inspectFuncTruncate != nil {
		mmTruncate.inspectFuncTruncate(size)
	}

	mm_params := &FileMockTruncateParams{size}

	// Record call args
	mmTruncate.TruncateMock.mutex.Lock()
	mmTruncate.TruncateMock.callArgs = append(mmTruncate.TruncateMock.callArgs, mm_params)
	mmTruncate.TruncateMock.mutex.Unlock()

	for _, e := range mmTruncate.TruncateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTruncate.TruncateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTruncate.TruncateMock.defaultExpectation.Counter, 1)
		mm_want := mmTruncate.TruncateMock.defaultExpectation.params
		mm_got := FileMockTruncateParams{size}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTruncate.t.Errorf("FileMock.Truncate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTruncate.TruncateMock.defaultExpectation.results
		if mm_results == nil {
			mmTruncate.t.Fatal("No results are set for the FileMock.Truncate")
		}
		return (*mm_results).err
	}
	if mmTruncate.funcTruncate != nil {
		return mmTruncate.funcTruncate(size)
	}
	mmTruncate.t.Fatalf("Unexpected call to FileMock.Truncate. %v", size)
	return
}

// TruncateAfterCounter returns a count of finished FileMock.Truncate invocations
func (mmTruncate *FileMock) TruncateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncate.afterTruncateCounter)
}

// TruncateBeforeCounter returns a count of FileMock.Truncate invocations
func (mmTruncate *FileMock) TruncateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncate.beforeTruncateCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Truncate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTruncate *mFileMockTruncate) Calls() []*FileMockTruncateParams {
	mmTruncate.mutex.RLock()

	argCopy := make([]*FileMockTruncateParams, len(mmTruncate.callArgs))
	copy(argCopy, mmTruncate.callArgs)

	mmTruncate.mutex.RUnlock()

	return argCopy
}

// MinimockTruncateDone returns true if the count of the Truncate invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockTruncateDone() bool {
	for _, e := range m.TruncateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncate != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		return false
	}
	return true
}

// MinimockTruncateInspect logs each unmet expectation
func (m *FileMock) MinimockTruncateInspect() {
	for _, e := range m.TruncateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Truncate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		if m.TruncateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Truncate")
		} else {
			m.t.Errorf("Expected call to FileMock.Truncate with params: %#v", *m.TruncateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncate != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		m.t.Error("Expected call to FileMock.Truncate")
	}
}

type mFileMockWrite struct {
	mock               *FileMock
	defaultExpectation *FileMockWriteExpectation
	expectations       []*FileMockWriteExpectation

	callArgs []*FileMockWriteParams
	mutex    sync.RWMutex
}

// FileMockWriteExpectation specifies expectation struct of the File.Write
type FileMockWriteExpectation struct {
	mock    *FileMock
	params  *FileMockWriteParams
	results *FileMockWriteResults
	Counter uint64
}

// FileMockWriteParams contains parameters of the File.Write
type FileMockWriteParams struct {
	p []byte
}

// FileMockWriteResults contains results of the File.Write
type FileMockWriteResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.Write
func (mmWrite *mFileMockWrite) Expect(p []byte) *mFileMockWrite {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &FileMockWriteExpectation{}
	}

	mmWrite.defaultExpectation.params = &FileMockWriteParams{p}
	for _, e := range mmWrite.expectations {
		if minimock.Equal(e.params, mmWrite.defaultExpectation.params) {
			mmWrite.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWrite.defaultExpectation.params)
		}
	}

	return mmWrite
}

// Inspect accepts an inspector function that has same arguments as the File.Write
func (mmWrite *mFileMockWrite) Inspect(f func(p []byte)) *mFileMockWrite {
	if mmWrite.mock.inspectFuncWrite != nil {
		mmWrite.mock.t.Fatalf("Inspect function is already set for FileMock.Write")
	}

	mmWrite.mock.inspectFuncWrite = f

	return mmWrite
}

// Return sets up results that will be returned by File.Write
func (mmWrite *mFileMockWrite) Return(n int, err error) *FileMock {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &FileMockWriteExpectation{mock: mmWrite.mock}
	}
	mmWrite.defaultExpectation.results = &FileMockWriteResults{n, err}
	return mmWrite.mock
}

//Set uses given function f to mock the File.Write method
func (mmWrite *mFileMockWrite) Set(f func(p []byte) (n int, err error)) *FileMock {
	if mmWrite.defaultExpectation != nil {
		mmWrite.mock.t.Fatalf("Default expectation is already set for the File.Write method")
	}

	if len(mmWrite.expectations) > 0 {
		mmWrite.mock.t.Fatalf("Some expectations are already set for the File.Write method")
	}

	mmWrite.mock.funcWrite = f
	return mmWrite.mock
}

// When sets expectation for the File.Write which will trigger the result defined by the following
// Then helper
func (mmWrite *mFileMockWrite) When(p []byte) *FileMockWriteExpectation {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	expectation := &FileMockWriteExpectation{
		mock:   mmWrite.mock,
		params: &FileMockWriteParams{p},
	}
	mmWrite.expectations = append(mmWrite.expectations, expectation)
	return expectation
}

// Then sets up File.Write return parameters for the expectation previously defined by the When method
func (e *FileMockWriteExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockWriteResults{n, err}
	return e.mock
}

// Write implements afero.File
func (mmWrite *FileMock) Write(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmWrite.beforeWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmWrite.afterWriteCounter, 1)

	if mmWrite.inspectFuncWrite != nil {
		mmWrite.inspectFuncWrite(p)
	}

	mm_params := &FileMockWriteParams{p}

	// Record call args
	mmWrite.WriteMock.mutex.Lock()
	mmWrite.WriteMock.callArgs = append(mmWrite.WriteMock.callArgs, mm_params)
	mmWrite.WriteMock.mutex.Unlock()

	for _, e := range mmWrite.WriteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWrite.WriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWrite.WriteMock.defaultExpectation.Counter, 1)
		mm_want := mmWrite.WriteMock.defaultExpectation.params
		mm_got := FileMockWriteParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWrite.t.Errorf("FileMock.Write got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWrite.WriteMock.defaultExpectation.results
		if mm_results == nil {
			mmWrite.t.Fatal("No results are set for the FileMock.Write")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWrite.funcWrite != nil {
		return mmWrite.funcWrite(p)
	}
	mmWrite.t.Fatalf("Unexpected call to FileMock.Write. %v", p)
	return
}

// WriteAfterCounter returns a count of finished FileMock.Write invocations
func (mmWrite *FileMock) WriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.afterWriteCounter)
}

// WriteBeforeCounter returns a count of FileMock.Write invocations
func (mmWrite *FileMock) WriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.beforeWriteCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Write.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWrite *mFileMockWrite) Calls() []*FileMockWriteParams {
	mmWrite.mutex.RLock()

	argCopy := make([]*FileMockWriteParams, len(mmWrite.callArgs))
	copy(argCopy, mmWrite.callArgs)

	mmWrite.mutex.RUnlock()

	return argCopy
}

// MinimockWriteDone returns true if the count of the Write invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockWriteDone() bool {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteInspect logs each unmet expectation
func (m *FileMock) MinimockWriteInspect() {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Write with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		if m.WriteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Write")
		} else {
			m.t.Errorf("Expected call to FileMock.Write with params: %#v", *m.WriteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		m.t.Error("Expected call to FileMock.Write")
	}
}

type mFileMockWriteAt struct {
	mock               *FileMock
	defaultExpectation *FileMockWriteAtExpectation
	expectations       []*FileMockWriteAtExpectation

	callArgs []*FileMockWriteAtParams
	mutex    sync.RWMutex
}

// FileMockWriteAtExpectation specifies expectation struct of the File.WriteAt
type FileMockWriteAtExpectation struct {
	mock    *FileMock
	params  *FileMockWriteAtParams
	results *FileMockWriteAtResults
	Counter uint64
}

// FileMockWriteAtParams contains parameters of the File.WriteAt
type FileMockWriteAtParams struct {
	p   []byte
	off int64
}

// FileMockWriteAtResults contains results of the File.WriteAt
type FileMockWriteAtResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.WriteAt
func (mmWriteAt *mFileMockWriteAt) Expect(p []byte, off int64) *mFileMockWriteAt {
	if mmWriteAt.mock.funcWriteAt != nil {
		mmWriteAt.mock.t.Fatalf("FileMock.WriteAt mock is already set by Set")
	}

	if mmWriteAt.defaultExpectation == nil {
		mmWriteAt.defaultExpectation = &FileMockWriteAtExpectation{}
	}

	mmWriteAt.defaultExpectation.params = &FileMockWriteAtParams{p, off}
	for _, e := range mmWriteAt.expectations {
		if minimock.Equal(e.params, mmWriteAt.defaultExpectation.params) {
			mmWriteAt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteAt.defaultExpectation.params)
		}
	}

	return mmWriteAt
}

// Inspect accepts an inspector function that has same arguments as the File.WriteAt
func (mmWriteAt *mFileMockWriteAt) Inspect(f func(p []byte, off int64)) *mFileMockWriteAt {
	if mmWriteAt.mock.inspectFuncWriteAt != nil {
		mmWriteAt.mock.t.Fatalf("Inspect function is already set for FileMock.WriteAt")
	}

	mmWriteAt.mock.inspectFuncWriteAt = f

	return mmWriteAt
}

// Return sets up results that will be returned by File.WriteAt
func (mmWriteAt *mFileMockWriteAt) Return(n int, err error) *FileMock {
	if mmWriteAt.mock.funcWriteAt != nil {
		mmWriteAt.mock.t.Fatalf("FileMock.WriteAt mock is already set by Set")
	}

	if mmWriteAt.defaultExpectation == nil {
		mmWriteAt.defaultExpectation = &FileMockWriteAtExpectation{mock: mmWriteAt.mock}
	}
	mmWriteAt.defaultExpectation.results = &FileMockWriteAtResults{n, err}
	return mmWriteAt.mock
}

//Set uses given function f to mock the File.WriteAt method
func (mmWriteAt *mFileMockWriteAt) Set(f func(p []byte, off int64) (n int, err error)) *FileMock {
	if mmWriteAt.defaultExpectation != nil {
		mmWriteAt.mock.t.Fatalf("Default expectation is already set for the File.WriteAt method")
	}

	if len(mmWriteAt.expectations) > 0 {
		mmWriteAt.mock.t.Fatalf("Some expectations are already set for the File.WriteAt method")
	}

	mmWriteAt.mock.funcWriteAt = f
	return mmWriteAt.mock
}

// When sets expectation for the File.WriteAt which will trigger the result defined by the following
// Then helper
func (mmWriteAt *mFileMockWriteAt) When(p []byte, off int64) *FileMockWriteAtExpectation {
	if mmWriteAt.mock.funcWriteAt != nil {
		mmWriteAt.mock.t.Fatalf("FileMock.WriteAt mock is already set by Set")
	}

	expectation := &FileMockWriteAtExpectation{
		mock:   mmWriteAt.mock,
		params: &FileMockWriteAtParams{p, off},
	}
	mmWriteAt.expectations = append(mmWriteAt.expectations, expectation)
	return expectation
}

// Then sets up File.WriteAt return parameters for the expectation previously defined by the When method
func (e *FileMockWriteAtExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockWriteAtResults{n, err}
	return e.mock
}

// WriteAt implements afero.File
func (mmWriteAt *FileMock) WriteAt(p []byte, off int64) (n int, err error) {
	mm_atomic.AddUint64(&mmWriteAt.beforeWriteAtCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteAt.afterWriteAtCounter, 1)

	if mmWriteAt.inspectFuncWriteAt != nil {
		mmWriteAt.inspectFuncWriteAt(p, off)
	}

	mm_params := &FileMockWriteAtParams{p, off}

	// Record call args
	mmWriteAt.WriteAtMock.mutex.Lock()
	mmWriteAt.WriteAtMock.callArgs = append(mmWriteAt.WriteAtMock.callArgs, mm_params)
	mmWriteAt.WriteAtMock.mutex.Unlock()

	for _, e := range mmWriteAt.WriteAtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteAt.WriteAtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteAt.WriteAtMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteAt.WriteAtMock.defaultExpectation.params
		mm_got := FileMockWriteAtParams{p, off}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteAt.t.Errorf("FileMock.WriteAt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteAt.WriteAtMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteAt.t.Fatal("No results are set for the FileMock.WriteAt")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteAt.funcWriteAt != nil {
		return mmWriteAt.funcWriteAt(p, off)
	}
	mmWriteAt.t.Fatalf("Unexpected call to FileMock.WriteAt. %v %v", p, off)
	return
}

// WriteAtAfterCounter returns a count of finished FileMock.WriteAt invocations
func (mmWriteAt *FileMock) WriteAtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteAt.afterWriteAtCounter)
}

// WriteAtBeforeCounter returns a count of FileMock.WriteAt invocations
func (mmWriteAt *FileMock) WriteAtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteAt.beforeWriteAtCounter)
}

// Calls returns a list of arguments used in each call to FileMock.WriteAt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteAt *mFileMockWriteAt) Calls() []*FileMockWriteAtParams {
	mmWriteAt.mutex.RLock()

	argCopy := make([]*FileMockWriteAtParams, len(mmWriteAt.callArgs))
	copy(argCopy, mmWriteAt.callArgs)

	mmWriteAt.mutex.RUnlock()

	return argCopy
}

// MinimockWriteAtDone returns true if the count of the WriteAt invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockWriteAtDone() bool {
	for _, e := range m.WriteAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteAtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteAt != nil && mm_atomic.LoadUint64(&m.afterWriteAtCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteAtInspect logs each unmet expectation
func (m *FileMock) MinimockWriteAtInspect() {
	for _, e := range m.WriteAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.WriteAt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteAtCounter) < 1 {
		if m.WriteAtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.WriteAt")
		} else {
			m.t.Errorf("Expected call to FileMock.WriteAt with params: %#v", *m.WriteAtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteAt != nil && mm_atomic.LoadUint64(&m.afterWriteAtCounter) < 1 {
		m.t.Error("Expected call to FileMock.WriteAt")
	}
}

type mFileMockWriteString struct {
	mock               *FileMock
	defaultExpectation *FileMockWriteStringExpectation
	expectations       []*FileMockWriteStringExpectation

	callArgs []*FileMockWriteStringParams
	mutex    sync.RWMutex
}

// FileMockWriteStringExpectation specifies expectation struct of the File.WriteString
type FileMockWriteStringExpectation struct {
	mock    *FileMock
	params  *FileMockWriteStringParams
	results *FileMockWriteStringResults
	Counter uint64
}

// FileMockWriteStringParams contains parameters of the File.WriteString
type FileMockWriteStringParams struct {
	s string
}

// FileMockWriteStringResults contains results of the File.WriteString
type FileMockWriteStringResults struct {
	ret int
	err error
}

// Expect sets up expected params for File.WriteString
func (mmWriteString *mFileMockWriteString) Expect(s string) *mFileMockWriteString {
	if mmWriteString.mock.funcWriteString != nil {
		mmWriteString.mock.t.Fatalf("FileMock.WriteString mock is already set by Set")
	}

	if mmWriteString.defaultExpectation == nil {
		mmWriteString.defaultExpectation = &FileMockWriteStringExpectation{}
	}

	mmWriteString.defaultExpectation.params = &FileMockWriteStringParams{s}
	for _, e := range mmWriteString.expectations {
		if minimock.Equal(e.params, mmWriteString.defaultExpectation.params) {
			mmWriteString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteString.defaultExpectation.params)
		}
	}

	return mmWriteString
}

// Inspect accepts an inspector function that has same arguments as the File.WriteString
func (mmWriteString *mFileMockWriteString) Inspect(f func(s string)) *mFileMockWriteString {
	if mmWriteString.mock.inspectFuncWriteString != nil {
		mmWriteString.mock.t.Fatalf("Inspect function is already set for FileMock.WriteString")
	}

	mmWriteString.mock.inspectFuncWriteString = f

	return mmWriteString
}

// Return sets up results that will be returned by File.WriteString
func (mmWriteString *mFileMockWriteString) Return(ret int, err error) *FileMock {
	if mmWriteString.mock.funcWriteString != nil {
		mmWriteString.mock.t.Fatalf("FileMock.WriteString mock is already set by Set")
	}

	if mmWriteString.defaultExpectation == nil {
		mmWriteString.defaultExpectation = &FileMockWriteStringExpectation{mock: mmWriteString.mock}
	}
	mmWriteString.defaultExpectation.results = &FileMockWriteStringResults{ret, err}
	return mmWriteString.mock
}

//Set uses given function f to mock the File.WriteString method
func (mmWriteString *mFileMockWriteString) Set(f func(s string) (ret int, err error)) *FileMock {
	if mmWriteString.defaultExpectation != nil {
		mmWriteString.mock.t.Fatalf("Default expectation is already set for the File.WriteString method")
	}

	if len(mmWriteString.expectations) > 0 {
		mmWriteString.mock.t.Fatalf("Some expectations are already set for the File.WriteString method")
	}

	mmWriteString.mock.funcWriteString = f
	return mmWriteString.mock
}

// When sets expectation for the File.WriteString which will trigger the result defined by the following
// Then helper
func (mmWriteString *mFileMockWriteString) When(s string) *FileMockWriteStringExpectation {
	if mmWriteString.mock.funcWriteString != nil {
		mmWriteString.mock.t.Fatalf("FileMock.WriteString mock is already set by Set")
	}

	expectation := &FileMockWriteStringExpectation{
		mock:   mmWriteString.mock,
		params: &FileMockWriteStringParams{s},
	}
	mmWriteString.expectations = append(mmWriteString.expectations, expectation)
	return expectation
}

// Then sets up File.WriteString return parameters for the expectation previously defined by the When method
func (e *FileMockWriteStringExpectation) Then(ret int, err error) *FileMock {
	e.results = &FileMockWriteStringResults{ret, err}
	return e.mock
}

// WriteString implements afero.File
func (mmWriteString *FileMock) WriteString(s string) (ret int, err error) {
	mm_atomic.AddUint64(&mmWriteString.beforeWriteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteString.afterWriteStringCounter, 1)

	if mmWriteString.inspectFuncWriteString != nil {
		mmWriteString.inspectFuncWriteString(s)
	}

	mm_params := &FileMockWriteStringParams{s}

	// Record call args
	mmWriteString.WriteStringMock.mutex.Lock()
	mmWriteString.WriteStringMock.callArgs = append(mmWriteString.WriteStringMock.callArgs, mm_params)
	mmWriteString.WriteStringMock.mutex.Unlock()

	for _, e := range mmWriteString.WriteStringMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ret, e.results.err
		}
	}

	if mmWriteString.WriteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteString.WriteStringMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteString.WriteStringMock.defaultExpectation.params
		mm_got := FileMockWriteStringParams{s}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteString.t.Errorf("FileMock.WriteString got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteString.WriteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteString.t.Fatal("No results are set for the FileMock.WriteString")
		}
		return (*mm_results).ret, (*mm_results).err
	}
	if mmWriteString.funcWriteString != nil {
		return mmWriteString.funcWriteString(s)
	}
	mmWriteString.t.Fatalf("Unexpected call to FileMock.WriteString. %v", s)
	return
}

// WriteStringAfterCounter returns a count of finished FileMock.WriteString invocations
func (mmWriteString *FileMock) WriteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteString.afterWriteStringCounter)
}

// WriteStringBeforeCounter returns a count of FileMock.WriteString invocations
func (mmWriteString *FileMock) WriteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteString.beforeWriteStringCounter)
}

// Calls returns a list of arguments used in each call to FileMock.WriteString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteString *mFileMockWriteString) Calls() []*FileMockWriteStringParams {
	mmWriteString.mutex.RLock()

	argCopy := make([]*FileMockWriteStringParams, len(mmWriteString.callArgs))
	copy(argCopy, mmWriteString.callArgs)

	mmWriteString.mutex.RUnlock()

	return argCopy
}

// MinimockWriteStringDone returns true if the count of the WriteString invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockWriteStringDone() bool {
	for _, e := range m.WriteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteString != nil && mm_atomic.LoadUint64(&m.afterWriteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteStringInspect logs each unmet expectation
func (m *FileMock) MinimockWriteStringInspect() {
	for _, e := range m.WriteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.WriteString with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteStringCounter) < 1 {
		if m.WriteStringMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.WriteString")
		} else {
			m.t.Errorf("Expected call to FileMock.WriteString with params: %#v", *m.WriteStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteString != nil && mm_atomic.LoadUint64(&m.afterWriteStringCounter) < 1 {
		m.t.Error("Expected call to FileMock.WriteString")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FileMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockNameInspect()

		m.MinimockReadInspect()

		m.MinimockReadAtInspect()

		m.MinimockReaddirInspect()

		m.MinimockReaddirnamesInspect()

		m.MinimockSeekInspect()

		m.MinimockStatInspect()

		m.MinimockSyncInspect()

		m.MinimockTruncateInspect()

		m.MinimockWriteInspect()

		m.MinimockWriteAtInspect()

		m.MinimockWriteStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FileMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FileMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockNameDone() &&
		m.MinimockReadDone() &&
		m.MinimockReadAtDone() &&
		m.MinimockReaddirDone() &&
		m.MinimockReaddirnamesDone() &&
		m.MinimockSeekDone() &&
		m.MinimockStatDone() &&
		m.MinimockSyncDone() &&
		m.MinimockTruncateDone() &&
		m.MinimockWriteDone() &&
		m.MinimockWriteAtDone() &&
		m.MinimockWriteStringDone()
}
