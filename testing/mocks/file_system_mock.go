package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/infrastructure.FileSystem -o ./testing/mocks/file_system_mock.go

import (
	"io"
	"os"
	"os/user"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FileSystemMock implements infrastructure.FileSystem
type FileSystemMock struct {
	t minimock.Tester

	funcChmod          func(path string, mode os.FileMode) (err error)
	inspectFuncChmod   func(path string, mode os.FileMode)
	afterChmodCounter  uint64
	beforeChmodCounter uint64
	ChmodMock          mFileSystemMockChmod

	funcChown          func(name string, user *user.User) (err error)
	inspectFuncChown   func(name string, user *user.User)
	afterChownCounter  uint64
	beforeChownCounter uint64
	ChownMock          mFileSystemMockChown

	funcDelete          func(path string) (err error)
	inspectFuncDelete   func(path string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mFileSystemMockDelete

	funcExist          func(path string) (b1 bool)
	inspectFuncExist   func(path string)
	afterExistCounter  uint64
	beforeExistCounter uint64
	ExistMock          mFileSystemMockExist

	funcRead          func(path string) (s1 string, err error)
	inspectFuncRead   func(path string)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mFileSystemMockRead

	funcReader          func(path string) (r1 io.ReadCloser, err error)
	inspectFuncReader   func(path string)
	afterReaderCounter  uint64
	beforeReaderCounter uint64
	ReaderMock          mFileSystemMockReader

	funcWrite          func(path string, content string) (err error)
	inspectFuncWrite   func(path string, content string)
	afterWriteCounter  uint64
	beforeWriteCounter uint64
	WriteMock          mFileSystemMockWrite
}

// NewFileSystemMock returns a mock for infrastructure.FileSystem
func NewFileSystemMock(t minimock.Tester) *FileSystemMock {
	m := &FileSystemMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChmodMock = mFileSystemMockChmod{mock: m}
	m.ChmodMock.callArgs = []*FileSystemMockChmodParams{}

	m.ChownMock = mFileSystemMockChown{mock: m}
	m.ChownMock.callArgs = []*FileSystemMockChownParams{}

	m.DeleteMock = mFileSystemMockDelete{mock: m}
	m.DeleteMock.callArgs = []*FileSystemMockDeleteParams{}

	m.ExistMock = mFileSystemMockExist{mock: m}
	m.ExistMock.callArgs = []*FileSystemMockExistParams{}

	m.ReadMock = mFileSystemMockRead{mock: m}
	m.ReadMock.callArgs = []*FileSystemMockReadParams{}

	m.ReaderMock = mFileSystemMockReader{mock: m}
	m.ReaderMock.callArgs = []*FileSystemMockReaderParams{}

	m.WriteMock = mFileSystemMockWrite{mock: m}
	m.WriteMock.callArgs = []*FileSystemMockWriteParams{}

	return m
}

type mFileSystemMockChmod struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockChmodExpectation
	expectations       []*FileSystemMockChmodExpectation

	callArgs []*FileSystemMockChmodParams
	mutex    sync.RWMutex
}

// FileSystemMockChmodExpectation specifies expectation struct of the FileSystem.Chmod
type FileSystemMockChmodExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockChmodParams
	results *FileSystemMockChmodResults
	Counter uint64
}

// FileSystemMockChmodParams contains parameters of the FileSystem.Chmod
type FileSystemMockChmodParams struct {
	path string
	mode os.FileMode
}

// FileSystemMockChmodResults contains results of the FileSystem.Chmod
type FileSystemMockChmodResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Chmod
func (mmChmod *mFileSystemMockChmod) Expect(path string, mode os.FileMode) *mFileSystemMockChmod {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileSystemMock.Chmod mock is already set by Set")
	}

	if mmChmod.defaultExpectation == nil {
		mmChmod.defaultExpectation = &FileSystemMockChmodExpectation{}
	}

	mmChmod.defaultExpectation.params = &FileSystemMockChmodParams{path, mode}
	for _, e := range mmChmod.expectations {
		if minimock.Equal(e.params, mmChmod.defaultExpectation.params) {
			mmChmod.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChmod.defaultExpectation.params)
		}
	}

	return mmChmod
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Chmod
func (mmChmod *mFileSystemMockChmod) Inspect(f func(path string, mode os.FileMode)) *mFileSystemMockChmod {
	if mmChmod.mock.inspectFuncChmod != nil {
		mmChmod.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Chmod")
	}

	mmChmod.mock.inspectFuncChmod = f

	return mmChmod
}

// Return sets up results that will be returned by FileSystem.Chmod
func (mmChmod *mFileSystemMockChmod) Return(err error) *FileSystemMock {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileSystemMock.Chmod mock is already set by Set")
	}

	if mmChmod.defaultExpectation == nil {
		mmChmod.defaultExpectation = &FileSystemMockChmodExpectation{mock: mmChmod.mock}
	}
	mmChmod.defaultExpectation.results = &FileSystemMockChmodResults{err}
	return mmChmod.mock
}

//Set uses given function f to mock the FileSystem.Chmod method
func (mmChmod *mFileSystemMockChmod) Set(f func(path string, mode os.FileMode) (err error)) *FileSystemMock {
	if mmChmod.defaultExpectation != nil {
		mmChmod.mock.t.Fatalf("Default expectation is already set for the FileSystem.Chmod method")
	}

	if len(mmChmod.expectations) > 0 {
		mmChmod.mock.t.Fatalf("Some expectations are already set for the FileSystem.Chmod method")
	}

	mmChmod.mock.funcChmod = f
	return mmChmod.mock
}

// When sets expectation for the FileSystem.Chmod which will trigger the result defined by the following
// Then helper
func (mmChmod *mFileSystemMockChmod) When(path string, mode os.FileMode) *FileSystemMockChmodExpectation {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileSystemMock.Chmod mock is already set by Set")
	}

	expectation := &FileSystemMockChmodExpectation{
		mock:   mmChmod.mock,
		params: &FileSystemMockChmodParams{path, mode},
	}
	mmChmod.expectations = append(mmChmod.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Chmod return parameters for the expectation previously defined by the When method
func (e *FileSystemMockChmodExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockChmodResults{err}
	return e.mock
}

// Chmod implements infrastructure.FileSystem
func (mmChmod *FileSystemMock) Chmod(path string, mode os.FileMode) (err error) {
	mm_atomic.AddUint64(&mmChmod.beforeChmodCounter, 1)
	defer mm_atomic.AddUint64(&mmChmod.afterChmodCounter, 1)

	if mmChmod.inspectFuncChmod != nil {
		mmChmod.inspectFuncChmod(path, mode)
	}

	mm_params := &FileSystemMockChmodParams{path, mode}

	// Record call args
	mmChmod.ChmodMock.mutex.Lock()
	mmChmod.ChmodMock.callArgs = append(mmChmod.ChmodMock.callArgs, mm_params)
	mmChmod.ChmodMock.mutex.Unlock()

	for _, e := range mmChmod.ChmodMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChmod.ChmodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChmod.ChmodMock.defaultExpectation.Counter, 1)
		mm_want := mmChmod.ChmodMock.defaultExpectation.params
		mm_got := FileSystemMockChmodParams{path, mode}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChmod.t.Errorf("FileSystemMock.Chmod got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChmod.ChmodMock.defaultExpectation.results
		if mm_results == nil {
			mmChmod.t.Fatal("No results are set for the FileSystemMock.Chmod")
		}
		return (*mm_results).err
	}
	if mmChmod.funcChmod != nil {
		return mmChmod.funcChmod(path, mode)
	}
	mmChmod.t.Fatalf("Unexpected call to FileSystemMock.Chmod. %v %v", path, mode)
	return
}

// ChmodAfterCounter returns a count of finished FileSystemMock.Chmod invocations
func (mmChmod *FileSystemMock) ChmodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChmod.afterChmodCounter)
}

// ChmodBeforeCounter returns a count of FileSystemMock.Chmod invocations
func (mmChmod *FileSystemMock) ChmodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChmod.beforeChmodCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Chmod.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChmod *mFileSystemMockChmod) Calls() []*FileSystemMockChmodParams {
	mmChmod.mutex.RLock()

	argCopy := make([]*FileSystemMockChmodParams, len(mmChmod.callArgs))
	copy(argCopy, mmChmod.callArgs)

	mmChmod.mutex.RUnlock()

	return argCopy
}

// MinimockChmodDone returns true if the count of the Chmod invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockChmodDone() bool {
	for _, e := range m.ChmodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChmodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChmod != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		return false
	}
	return true
}

// MinimockChmodInspect logs each unmet expectation
func (m *FileSystemMock) MinimockChmodInspect() {
	for _, e := range m.ChmodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Chmod with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChmodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		if m.ChmodMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Chmod")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Chmod with params: %#v", *m.ChmodMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChmod != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Chmod")
	}
}

type mFileSystemMockChown struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockChownExpectation
	expectations       []*FileSystemMockChownExpectation

	callArgs []*FileSystemMockChownParams
	mutex    sync.RWMutex
}

// FileSystemMockChownExpectation specifies expectation struct of the FileSystem.Chown
type FileSystemMockChownExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockChownParams
	results *FileSystemMockChownResults
	Counter uint64
}

// FileSystemMockChownParams contains parameters of the FileSystem.Chown
type FileSystemMockChownParams struct {
	name string
	user *user.User
}

// FileSystemMockChownResults contains results of the FileSystem.Chown
type FileSystemMockChownResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Chown
func (mmChown *mFileSystemMockChown) Expect(name string, user *user.User) *mFileSystemMockChown {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileSystemMock.Chown mock is already set by Set")
	}

	if mmChown.defaultExpectation == nil {
		mmChown.defaultExpectation = &FileSystemMockChownExpectation{}
	}

	mmChown.defaultExpectation.params = &FileSystemMockChownParams{name, user}
	for _, e := range mmChown.expectations {
		if minimock.Equal(e.params, mmChown.defaultExpectation.params) {
			mmChown.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChown.defaultExpectation.params)
		}
	}

	return mmChown
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Chown
func (mmChown *mFileSystemMockChown) Inspect(f func(name string, user *user.User)) *mFileSystemMockChown {
	if mmChown.mock.inspectFuncChown != nil {
		mmChown.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Chown")
	}

	mmChown.mock.inspectFuncChown = f

	return mmChown
}

// Return sets up results that will be returned by FileSystem.Chown
func (mmChown *mFileSystemMockChown) Return(err error) *FileSystemMock {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileSystemMock.Chown mock is already set by Set")
	}

	if mmChown.defaultExpectation == nil {
		mmChown.defaultExpectation = &FileSystemMockChownExpectation{mock: mmChown.mock}
	}
	mmChown.defaultExpectation.results = &FileSystemMockChownResults{err}
	return mmChown.mock
}

//Set uses given function f to mock the FileSystem.Chown method
func (mmChown *mFileSystemMockChown) Set(f func(name string, user *user.User) (err error)) *FileSystemMock {
	if mmChown.defaultExpectation != nil {
		mmChown.mock.t.Fatalf("Default expectation is already set for the FileSystem.Chown method")
	}

	if len(mmChown.expectations) > 0 {
		mmChown.mock.t.Fatalf("Some expectations are already set for the FileSystem.Chown method")
	}

	mmChown.mock.funcChown = f
	return mmChown.mock
}

// When sets expectation for the FileSystem.Chown which will trigger the result defined by the following
// Then helper
func (mmChown *mFileSystemMockChown) When(name string, user *user.User) *FileSystemMockChownExpectation {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileSystemMock.Chown mock is already set by Set")
	}

	expectation := &FileSystemMockChownExpectation{
		mock:   mmChown.mock,
		params: &FileSystemMockChownParams{name, user},
	}
	mmChown.expectations = append(mmChown.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Chown return parameters for the expectation previously defined by the When method
func (e *FileSystemMockChownExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockChownResults{err}
	return e.mock
}

// Chown implements infrastructure.FileSystem
func (mmChown *FileSystemMock) Chown(name string, user *user.User) (err error) {
	mm_atomic.AddUint64(&mmChown.beforeChownCounter, 1)
	defer mm_atomic.AddUint64(&mmChown.afterChownCounter, 1)

	if mmChown.inspectFuncChown != nil {
		mmChown.inspectFuncChown(name, user)
	}

	mm_params := &FileSystemMockChownParams{name, user}

	// Record call args
	mmChown.ChownMock.mutex.Lock()
	mmChown.ChownMock.callArgs = append(mmChown.ChownMock.callArgs, mm_params)
	mmChown.ChownMock.mutex.Unlock()

	for _, e := range mmChown.ChownMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChown.ChownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChown.ChownMock.defaultExpectation.Counter, 1)
		mm_want := mmChown.ChownMock.defaultExpectation.params
		mm_got := FileSystemMockChownParams{name, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChown.t.Errorf("FileSystemMock.Chown got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChown.ChownMock.defaultExpectation.results
		if mm_results == nil {
			mmChown.t.Fatal("No results are set for the FileSystemMock.Chown")
		}
		return (*mm_results).err
	}
	if mmChown.funcChown != nil {
		return mmChown.funcChown(name, user)
	}
	mmChown.t.Fatalf("Unexpected call to FileSystemMock.Chown. %v %v", name, user)
	return
}

// ChownAfterCounter returns a count of finished FileSystemMock.Chown invocations
func (mmChown *FileSystemMock) ChownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChown.afterChownCounter)
}

// ChownBeforeCounter returns a count of FileSystemMock.Chown invocations
func (mmChown *FileSystemMock) ChownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChown.beforeChownCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Chown.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChown *mFileSystemMockChown) Calls() []*FileSystemMockChownParams {
	mmChown.mutex.RLock()

	argCopy := make([]*FileSystemMockChownParams, len(mmChown.callArgs))
	copy(argCopy, mmChown.callArgs)

	mmChown.mutex.RUnlock()

	return argCopy
}

// MinimockChownDone returns true if the count of the Chown invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockChownDone() bool {
	for _, e := range m.ChownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChown != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		return false
	}
	return true
}

// MinimockChownInspect logs each unmet expectation
func (m *FileSystemMock) MinimockChownInspect() {
	for _, e := range m.ChownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Chown with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		if m.ChownMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Chown")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Chown with params: %#v", *m.ChownMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChown != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Chown")
	}
}

type mFileSystemMockDelete struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockDeleteExpectation
	expectations       []*FileSystemMockDeleteExpectation

	callArgs []*FileSystemMockDeleteParams
	mutex    sync.RWMutex
}

// FileSystemMockDeleteExpectation specifies expectation struct of the FileSystem.Delete
type FileSystemMockDeleteExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockDeleteParams
	results *FileSystemMockDeleteResults
	Counter uint64
}

// FileSystemMockDeleteParams contains parameters of the FileSystem.Delete
type FileSystemMockDeleteParams struct {
	path string
}

// FileSystemMockDeleteResults contains results of the FileSystem.Delete
type FileSystemMockDeleteResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Delete
func (mmDelete *mFileSystemMockDelete) Expect(path string) *mFileSystemMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("FileSystemMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &FileSystemMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &FileSystemMockDeleteParams{path}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Delete
func (mmDelete *mFileSystemMockDelete) Inspect(f func(path string)) *mFileSystemMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by FileSystem.Delete
func (mmDelete *mFileSystemMockDelete) Return(err error) *FileSystemMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("FileSystemMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &FileSystemMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &FileSystemMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the FileSystem.Delete method
func (mmDelete *mFileSystemMockDelete) Set(f func(path string) (err error)) *FileSystemMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the FileSystem.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the FileSystem.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the FileSystem.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mFileSystemMockDelete) When(path string) *FileSystemMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("FileSystemMock.Delete mock is already set by Set")
	}

	expectation := &FileSystemMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &FileSystemMockDeleteParams{path},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Delete return parameters for the expectation previously defined by the When method
func (e *FileSystemMockDeleteExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockDeleteResults{err}
	return e.mock
}

// Delete implements infrastructure.FileSystem
func (mmDelete *FileSystemMock) Delete(path string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(path)
	}

	mm_params := &FileSystemMockDeleteParams{path}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := FileSystemMockDeleteParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("FileSystemMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the FileSystemMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(path)
	}
	mmDelete.t.Fatalf("Unexpected call to FileSystemMock.Delete. %v", path)
	return
}

// DeleteAfterCounter returns a count of finished FileSystemMock.Delete invocations
func (mmDelete *FileSystemMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of FileSystemMock.Delete invocations
func (mmDelete *FileSystemMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mFileSystemMockDelete) Calls() []*FileSystemMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*FileSystemMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *FileSystemMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Delete")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Delete")
	}
}

type mFileSystemMockExist struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockExistExpectation
	expectations       []*FileSystemMockExistExpectation

	callArgs []*FileSystemMockExistParams
	mutex    sync.RWMutex
}

// FileSystemMockExistExpectation specifies expectation struct of the FileSystem.Exist
type FileSystemMockExistExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockExistParams
	results *FileSystemMockExistResults
	Counter uint64
}

// FileSystemMockExistParams contains parameters of the FileSystem.Exist
type FileSystemMockExistParams struct {
	path string
}

// FileSystemMockExistResults contains results of the FileSystem.Exist
type FileSystemMockExistResults struct {
	b1 bool
}

// Expect sets up expected params for FileSystem.Exist
func (mmExist *mFileSystemMockExist) Expect(path string) *mFileSystemMockExist {
	if mmExist.mock.funcExist != nil {
		mmExist.mock.t.Fatalf("FileSystemMock.Exist mock is already set by Set")
	}

	if mmExist.defaultExpectation == nil {
		mmExist.defaultExpectation = &FileSystemMockExistExpectation{}
	}

	mmExist.defaultExpectation.params = &FileSystemMockExistParams{path}
	for _, e := range mmExist.expectations {
		if minimock.Equal(e.params, mmExist.defaultExpectation.params) {
			mmExist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExist.defaultExpectation.params)
		}
	}

	return mmExist
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Exist
func (mmExist *mFileSystemMockExist) Inspect(f func(path string)) *mFileSystemMockExist {
	if mmExist.mock.inspectFuncExist != nil {
		mmExist.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Exist")
	}

	mmExist.mock.inspectFuncExist = f

	return mmExist
}

// Return sets up results that will be returned by FileSystem.Exist
func (mmExist *mFileSystemMockExist) Return(b1 bool) *FileSystemMock {
	if mmExist.mock.funcExist != nil {
		mmExist.mock.t.Fatalf("FileSystemMock.Exist mock is already set by Set")
	}

	if mmExist.defaultExpectation == nil {
		mmExist.defaultExpectation = &FileSystemMockExistExpectation{mock: mmExist.mock}
	}
	mmExist.defaultExpectation.results = &FileSystemMockExistResults{b1}
	return mmExist.mock
}

//Set uses given function f to mock the FileSystem.Exist method
func (mmExist *mFileSystemMockExist) Set(f func(path string) (b1 bool)) *FileSystemMock {
	if mmExist.defaultExpectation != nil {
		mmExist.mock.t.Fatalf("Default expectation is already set for the FileSystem.Exist method")
	}

	if len(mmExist.expectations) > 0 {
		mmExist.mock.t.Fatalf("Some expectations are already set for the FileSystem.Exist method")
	}

	mmExist.mock.funcExist = f
	return mmExist.mock
}

// When sets expectation for the FileSystem.Exist which will trigger the result defined by the following
// Then helper
func (mmExist *mFileSystemMockExist) When(path string) *FileSystemMockExistExpectation {
	if mmExist.mock.funcExist != nil {
		mmExist.mock.t.Fatalf("FileSystemMock.Exist mock is already set by Set")
	}

	expectation := &FileSystemMockExistExpectation{
		mock:   mmExist.mock,
		params: &FileSystemMockExistParams{path},
	}
	mmExist.expectations = append(mmExist.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Exist return parameters for the expectation previously defined by the When method
func (e *FileSystemMockExistExpectation) Then(b1 bool) *FileSystemMock {
	e.results = &FileSystemMockExistResults{b1}
	return e.mock
}

// Exist implements infrastructure.FileSystem
func (mmExist *FileSystemMock) Exist(path string) (b1 bool) {
	mm_atomic.AddUint64(&mmExist.beforeExistCounter, 1)
	defer mm_atomic.AddUint64(&mmExist.afterExistCounter, 1)

	if mmExist.inspectFuncExist != nil {
		mmExist.inspectFuncExist(path)
	}

	mm_params := &FileSystemMockExistParams{path}

	// Record call args
	mmExist.ExistMock.mutex.Lock()
	mmExist.ExistMock.callArgs = append(mmExist.ExistMock.callArgs, mm_params)
	mmExist.ExistMock.mutex.Unlock()

	for _, e := range mmExist.ExistMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmExist.ExistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExist.ExistMock.defaultExpectation.Counter, 1)
		mm_want := mmExist.ExistMock.defaultExpectation.params
		mm_got := FileSystemMockExistParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExist.t.Errorf("FileSystemMock.Exist got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExist.ExistMock.defaultExpectation.results
		if mm_results == nil {
			mmExist.t.Fatal("No results are set for the FileSystemMock.Exist")
		}
		return (*mm_results).b1
	}
	if mmExist.funcExist != nil {
		return mmExist.funcExist(path)
	}
	mmExist.t.Fatalf("Unexpected call to FileSystemMock.Exist. %v", path)
	return
}

// ExistAfterCounter returns a count of finished FileSystemMock.Exist invocations
func (mmExist *FileSystemMock) ExistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExist.afterExistCounter)
}

// ExistBeforeCounter returns a count of FileSystemMock.Exist invocations
func (mmExist *FileSystemMock) ExistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExist.beforeExistCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Exist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExist *mFileSystemMockExist) Calls() []*FileSystemMockExistParams {
	mmExist.mutex.RLock()

	argCopy := make([]*FileSystemMockExistParams, len(mmExist.callArgs))
	copy(argCopy, mmExist.callArgs)

	mmExist.mutex.RUnlock()

	return argCopy
}

// MinimockExistDone returns true if the count of the Exist invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockExistDone() bool {
	for _, e := range m.ExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExistCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExist != nil && mm_atomic.LoadUint64(&m.afterExistCounter) < 1 {
		return false
	}
	return true
}

// MinimockExistInspect logs each unmet expectation
func (m *FileSystemMock) MinimockExistInspect() {
	for _, e := range m.ExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Exist with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExistCounter) < 1 {
		if m.ExistMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Exist")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Exist with params: %#v", *m.ExistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExist != nil && mm_atomic.LoadUint64(&m.afterExistCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Exist")
	}
}

type mFileSystemMockRead struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockReadExpectation
	expectations       []*FileSystemMockReadExpectation

	callArgs []*FileSystemMockReadParams
	mutex    sync.RWMutex
}

// FileSystemMockReadExpectation specifies expectation struct of the FileSystem.Read
type FileSystemMockReadExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockReadParams
	results *FileSystemMockReadResults
	Counter uint64
}

// FileSystemMockReadParams contains parameters of the FileSystem.Read
type FileSystemMockReadParams struct {
	path string
}

// FileSystemMockReadResults contains results of the FileSystem.Read
type FileSystemMockReadResults struct {
	s1  string
	err error
}

// Expect sets up expected params for FileSystem.Read
func (mmRead *mFileSystemMockRead) Expect(path string) *mFileSystemMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileSystemMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FileSystemMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &FileSystemMockReadParams{path}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Read
func (mmRead *mFileSystemMockRead) Inspect(f func(path string)) *mFileSystemMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by FileSystem.Read
func (mmRead *mFileSystemMockRead) Return(s1 string, err error) *FileSystemMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileSystemMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FileSystemMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &FileSystemMockReadResults{s1, err}
	return mmRead.mock
}

//Set uses given function f to mock the FileSystem.Read method
func (mmRead *mFileSystemMockRead) Set(f func(path string) (s1 string, err error)) *FileSystemMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the FileSystem.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the FileSystem.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the FileSystem.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mFileSystemMockRead) When(path string) *FileSystemMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileSystemMock.Read mock is already set by Set")
	}

	expectation := &FileSystemMockReadExpectation{
		mock:   mmRead.mock,
		params: &FileSystemMockReadParams{path},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Read return parameters for the expectation previously defined by the When method
func (e *FileSystemMockReadExpectation) Then(s1 string, err error) *FileSystemMock {
	e.results = &FileSystemMockReadResults{s1, err}
	return e.mock
}

// Read implements infrastructure.FileSystem
func (mmRead *FileSystemMock) Read(path string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(path)
	}

	mm_params := &FileSystemMockReadParams{path}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, mm_params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRead.ReadMock.defaultExpectation.params
		mm_got := FileSystemMockReadParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRead.t.Errorf("FileSystemMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRead.ReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRead.t.Fatal("No results are set for the FileSystemMock.Read")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(path)
	}
	mmRead.t.Fatalf("Unexpected call to FileSystemMock.Read. %v", path)
	return
}

// ReadAfterCounter returns a count of finished FileSystemMock.Read invocations
func (mmRead *FileSystemMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of FileSystemMock.Read invocations
func (mmRead *FileSystemMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mFileSystemMockRead) Calls() []*FileSystemMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*FileSystemMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *FileSystemMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Read")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Read")
	}
}

type mFileSystemMockReader struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockReaderExpectation
	expectations       []*FileSystemMockReaderExpectation

	callArgs []*FileSystemMockReaderParams
	mutex    sync.RWMutex
}

// FileSystemMockReaderExpectation specifies expectation struct of the FileSystem.Reader
type FileSystemMockReaderExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockReaderParams
	results *FileSystemMockReaderResults
	Counter uint64
}

// FileSystemMockReaderParams contains parameters of the FileSystem.Reader
type FileSystemMockReaderParams struct {
	path string
}

// FileSystemMockReaderResults contains results of the FileSystem.Reader
type FileSystemMockReaderResults struct {
	r1  io.ReadCloser
	err error
}

// Expect sets up expected params for FileSystem.Reader
func (mmReader *mFileSystemMockReader) Expect(path string) *mFileSystemMockReader {
	if mmReader.mock.funcReader != nil {
		mmReader.mock.t.Fatalf("FileSystemMock.Reader mock is already set by Set")
	}

	if mmReader.defaultExpectation == nil {
		mmReader.defaultExpectation = &FileSystemMockReaderExpectation{}
	}

	mmReader.defaultExpectation.params = &FileSystemMockReaderParams{path}
	for _, e := range mmReader.expectations {
		if minimock.Equal(e.params, mmReader.defaultExpectation.params) {
			mmReader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReader.defaultExpectation.params)
		}
	}

	return mmReader
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Reader
func (mmReader *mFileSystemMockReader) Inspect(f func(path string)) *mFileSystemMockReader {
	if mmReader.mock.inspectFuncReader != nil {
		mmReader.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Reader")
	}

	mmReader.mock.inspectFuncReader = f

	return mmReader
}

// Return sets up results that will be returned by FileSystem.Reader
func (mmReader *mFileSystemMockReader) Return(r1 io.ReadCloser, err error) *FileSystemMock {
	if mmReader.mock.funcReader != nil {
		mmReader.mock.t.Fatalf("FileSystemMock.Reader mock is already set by Set")
	}

	if mmReader.defaultExpectation == nil {
		mmReader.defaultExpectation = &FileSystemMockReaderExpectation{mock: mmReader.mock}
	}
	mmReader.defaultExpectation.results = &FileSystemMockReaderResults{r1, err}
	return mmReader.mock
}

//Set uses given function f to mock the FileSystem.Reader method
func (mmReader *mFileSystemMockReader) Set(f func(path string) (r1 io.ReadCloser, err error)) *FileSystemMock {
	if mmReader.defaultExpectation != nil {
		mmReader.mock.t.Fatalf("Default expectation is already set for the FileSystem.Reader method")
	}

	if len(mmReader.expectations) > 0 {
		mmReader.mock.t.Fatalf("Some expectations are already set for the FileSystem.Reader method")
	}

	mmReader.mock.funcReader = f
	return mmReader.mock
}

// When sets expectation for the FileSystem.Reader which will trigger the result defined by the following
// Then helper
func (mmReader *mFileSystemMockReader) When(path string) *FileSystemMockReaderExpectation {
	if mmReader.mock.funcReader != nil {
		mmReader.mock.t.Fatalf("FileSystemMock.Reader mock is already set by Set")
	}

	expectation := &FileSystemMockReaderExpectation{
		mock:   mmReader.mock,
		params: &FileSystemMockReaderParams{path},
	}
	mmReader.expectations = append(mmReader.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Reader return parameters for the expectation previously defined by the When method
func (e *FileSystemMockReaderExpectation) Then(r1 io.ReadCloser, err error) *FileSystemMock {
	e.results = &FileSystemMockReaderResults{r1, err}
	return e.mock
}

// Reader implements infrastructure.FileSystem
func (mmReader *FileSystemMock) Reader(path string) (r1 io.ReadCloser, err error) {
	mm_atomic.AddUint64(&mmReader.beforeReaderCounter, 1)
	defer mm_atomic.AddUint64(&mmReader.afterReaderCounter, 1)

	if mmReader.inspectFuncReader != nil {
		mmReader.inspectFuncReader(path)
	}

	mm_params := &FileSystemMockReaderParams{path}

	// Record call args
	mmReader.ReaderMock.mutex.Lock()
	mmReader.ReaderMock.callArgs = append(mmReader.ReaderMock.callArgs, mm_params)
	mmReader.ReaderMock.mutex.Unlock()

	for _, e := range mmReader.ReaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmReader.ReaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReader.ReaderMock.defaultExpectation.Counter, 1)
		mm_want := mmReader.ReaderMock.defaultExpectation.params
		mm_got := FileSystemMockReaderParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReader.t.Errorf("FileSystemMock.Reader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReader.ReaderMock.defaultExpectation.results
		if mm_results == nil {
			mmReader.t.Fatal("No results are set for the FileSystemMock.Reader")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmReader.funcReader != nil {
		return mmReader.funcReader(path)
	}
	mmReader.t.Fatalf("Unexpected call to FileSystemMock.Reader. %v", path)
	return
}

// ReaderAfterCounter returns a count of finished FileSystemMock.Reader invocations
func (mmReader *FileSystemMock) ReaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReader.afterReaderCounter)
}

// ReaderBeforeCounter returns a count of FileSystemMock.Reader invocations
func (mmReader *FileSystemMock) ReaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReader.beforeReaderCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Reader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReader *mFileSystemMockReader) Calls() []*FileSystemMockReaderParams {
	mmReader.mutex.RLock()

	argCopy := make([]*FileSystemMockReaderParams, len(mmReader.callArgs))
	copy(argCopy, mmReader.callArgs)

	mmReader.mutex.RUnlock()

	return argCopy
}

// MinimockReaderDone returns true if the count of the Reader invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockReaderDone() bool {
	for _, e := range m.ReaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReader != nil && mm_atomic.LoadUint64(&m.afterReaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockReaderInspect logs each unmet expectation
func (m *FileSystemMock) MinimockReaderInspect() {
	for _, e := range m.ReaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Reader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaderCounter) < 1 {
		if m.ReaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Reader")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Reader with params: %#v", *m.ReaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReader != nil && mm_atomic.LoadUint64(&m.afterReaderCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Reader")
	}
}

type mFileSystemMockWrite struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockWriteExpectation
	expectations       []*FileSystemMockWriteExpectation

	callArgs []*FileSystemMockWriteParams
	mutex    sync.RWMutex
}

// FileSystemMockWriteExpectation specifies expectation struct of the FileSystem.Write
type FileSystemMockWriteExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockWriteParams
	results *FileSystemMockWriteResults
	Counter uint64
}

// FileSystemMockWriteParams contains parameters of the FileSystem.Write
type FileSystemMockWriteParams struct {
	path    string
	content string
}

// FileSystemMockWriteResults contains results of the FileSystem.Write
type FileSystemMockWriteResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Write
func (mmWrite *mFileSystemMockWrite) Expect(path string, content string) *mFileSystemMockWrite {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileSystemMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &FileSystemMockWriteExpectation{}
	}

	mmWrite.defaultExpectation.params = &FileSystemMockWriteParams{path, content}
	for _, e := range mmWrite.expectations {
		if minimock.Equal(e.params, mmWrite.defaultExpectation.params) {
			mmWrite.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWrite.defaultExpectation.params)
		}
	}

	return mmWrite
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Write
func (mmWrite *mFileSystemMockWrite) Inspect(f func(path string, content string)) *mFileSystemMockWrite {
	if mmWrite.mock.inspectFuncWrite != nil {
		mmWrite.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Write")
	}

	mmWrite.mock.inspectFuncWrite = f

	return mmWrite
}

// Return sets up results that will be returned by FileSystem.Write
func (mmWrite *mFileSystemMockWrite) Return(err error) *FileSystemMock {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileSystemMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &FileSystemMockWriteExpectation{mock: mmWrite.mock}
	}
	mmWrite.defaultExpectation.results = &FileSystemMockWriteResults{err}
	return mmWrite.mock
}

//Set uses given function f to mock the FileSystem.Write method
func (mmWrite *mFileSystemMockWrite) Set(f func(path string, content string) (err error)) *FileSystemMock {
	if mmWrite.defaultExpectation != nil {
		mmWrite.mock.t.Fatalf("Default expectation is already set for the FileSystem.Write method")
	}

	if len(mmWrite.expectations) > 0 {
		mmWrite.mock.t.Fatalf("Some expectations are already set for the FileSystem.Write method")
	}

	mmWrite.mock.funcWrite = f
	return mmWrite.mock
}

// When sets expectation for the FileSystem.Write which will trigger the result defined by the following
// Then helper
func (mmWrite *mFileSystemMockWrite) When(path string, content string) *FileSystemMockWriteExpectation {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileSystemMock.Write mock is already set by Set")
	}

	expectation := &FileSystemMockWriteExpectation{
		mock:   mmWrite.mock,
		params: &FileSystemMockWriteParams{path, content},
	}
	mmWrite.expectations = append(mmWrite.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Write return parameters for the expectation previously defined by the When method
func (e *FileSystemMockWriteExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockWriteResults{err}
	return e.mock
}

// Write implements infrastructure.FileSystem
func (mmWrite *FileSystemMock) Write(path string, content string) (err error) {
	mm_atomic.AddUint64(&mmWrite.beforeWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmWrite.afterWriteCounter, 1)

	if mmWrite.inspectFuncWrite != nil {
		mmWrite.inspectFuncWrite(path, content)
	}

	mm_params := &FileSystemMockWriteParams{path, content}

	// Record call args
	mmWrite.WriteMock.mutex.Lock()
	mmWrite.WriteMock.callArgs = append(mmWrite.WriteMock.callArgs, mm_params)
	mmWrite.WriteMock.mutex.Unlock()

	for _, e := range mmWrite.WriteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWrite.WriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWrite.WriteMock.defaultExpectation.Counter, 1)
		mm_want := mmWrite.WriteMock.defaultExpectation.params
		mm_got := FileSystemMockWriteParams{path, content}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWrite.t.Errorf("FileSystemMock.Write got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWrite.WriteMock.defaultExpectation.results
		if mm_results == nil {
			mmWrite.t.Fatal("No results are set for the FileSystemMock.Write")
		}
		return (*mm_results).err
	}
	if mmWrite.funcWrite != nil {
		return mmWrite.funcWrite(path, content)
	}
	mmWrite.t.Fatalf("Unexpected call to FileSystemMock.Write. %v %v", path, content)
	return
}

// WriteAfterCounter returns a count of finished FileSystemMock.Write invocations
func (mmWrite *FileSystemMock) WriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.afterWriteCounter)
}

// WriteBeforeCounter returns a count of FileSystemMock.Write invocations
func (mmWrite *FileSystemMock) WriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.beforeWriteCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Write.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWrite *mFileSystemMockWrite) Calls() []*FileSystemMockWriteParams {
	mmWrite.mutex.RLock()

	argCopy := make([]*FileSystemMockWriteParams, len(mmWrite.callArgs))
	copy(argCopy, mmWrite.callArgs)

	mmWrite.mutex.RUnlock()

	return argCopy
}

// MinimockWriteDone returns true if the count of the Write invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockWriteDone() bool {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteInspect logs each unmet expectation
func (m *FileSystemMock) MinimockWriteInspect() {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Write with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		if m.WriteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Write")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Write with params: %#v", *m.WriteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Write")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FileSystemMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChmodInspect()

		m.MinimockChownInspect()

		m.MinimockDeleteInspect()

		m.MinimockExistInspect()

		m.MinimockReadInspect()

		m.MinimockReaderInspect()

		m.MinimockWriteInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FileSystemMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FileSystemMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChmodDone() &&
		m.MinimockChownDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockExistDone() &&
		m.MinimockReadDone() &&
		m.MinimockReaderDone() &&
		m.MinimockWriteDone()
}
